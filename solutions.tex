
\documentclass{article}
\usepackage{CJK}
\usepackage[top=1in, bottom=1in, left=1.2in, right=1.2in]{geometry}
\usepackage{multirow}
\usepackage{indentfirst}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{color}
\usepackage[colorlinks,linkcolor=blue]{hyperref}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\usepackage{listings}
\lstset{numbers=left, 
		basicstyle=\small\ttfamily,
		language=C++, 
		breaklines, 
		extendedchars=false, 
		keywordstyle=\color{blue}\bfseries,
		frame=none,
		tabsize=4,
		commentstyle=\color{gray},
		stringstyle=\emph\bfseries,
		columns=flexible
		}
\begin{document}
\begin{CJK*}{UTF8}{gkai}
\CJKindent
\title{Solutions of leetcode}
\author{hustsxh@gmail.com}

\maketitle

	
\section{Problems Classify}

\subsection*{ Sort }
\label{ Sort }
\hyperref[ Insert Interval ]{ Insert Interval },
\hyperref[ Insertion Sort List ]{ Insertion Sort List },
\hyperref[ Largest Number ]{ Largest Number },
\hyperref[ Maximum Gap ]{ Maximum Gap },
\hyperref[ Merge Intervals ]{ Merge Intervals },
\hyperref[ Sort Colors ]{ Sort Colors },
\hyperref[ Sort List ]{ Sort List }

\subsection*{ Data Structure }
\label{ Data Structure }
\hyperref[ LRU Cache ]{ LRU Cache },
\hyperref[ Min Stack ]{ Min Stack }

\subsection*{ Dynamic Programming }
\label{ Dynamic Programming }
\hyperref[ Best Time to Buy and Sell Stock III ]{ Best Time to Buy and Sell Stock III },
\hyperref[ Best Time to Buy and Sell Stock ]{ Best Time to Buy and Sell Stock },
\hyperref[ Climbing Stairs ]{ Climbing Stairs },
\hyperref[ Decode Ways ]{ Decode Ways },
\hyperref[ Distinct Subsequences ]{ Distinct Subsequences },
\hyperref[ Dungeon Game ]{ Dungeon Game },
\hyperref[ Edit Distance ]{ Edit Distance },
\hyperref[ Interleaving String ]{ Interleaving String },
\hyperref[ Longest Valid Parentheses ]{ Longest Valid Parentheses },
\hyperref[ Maximal Rectangle ]{ Maximal Rectangle },
\hyperref[ Maximum Product Subarray ]{ Maximum Product Subarray },
\hyperref[ Maximum Subarray ]{ Maximum Subarray },
\hyperref[ Minimum Path Sum ]{ Minimum Path Sum },
\hyperref[ Palindrome Partitioning II ]{ Palindrome Partitioning II },
\hyperref[ Regular Expression Matching ]{ Regular Expression Matching },
\hyperref[ Scramble String ]{ Scramble String },
\hyperref[ Triangle ]{ Triangle },
\hyperref[ Unique Binary Search Trees II ]{ Unique Binary Search Trees II },
\hyperref[ Unique Binary Search Trees ]{ Unique Binary Search Trees },
\hyperref[ Unique Paths II ]{ Unique Paths II },
\hyperref[ Unique Paths ]{ Unique Paths },
\hyperref[ Wildcard Matching ]{ Wildcard Matching },
\hyperref[ Word Break II ]{ Word Break II },
\hyperref[ Word Break ]{ Word Break }

\subsection*{ Divide and Conquer }
\label{ Divide and Conquer }
\hyperref[ Majority Element ]{ Majority Element },
\hyperref[ Maximum Subarray ]{ Maximum Subarray },
\hyperref[ Median of Two Sorted Arrays ]{ Median of Two Sorted Arrays },
\hyperref[ Merge k Sorted Lists ]{ Merge k Sorted Lists }

\subsection*{ String }
\label{ String }
\hyperref[ Add Binary ]{ Add Binary },
\hyperref[ Anagrams ]{ Anagrams },
\hyperref[ Compare Version Numbers ]{ Compare Version Numbers },
\hyperref[ Count and Say ]{ Count and Say },
\hyperref[ Decode Ways ]{ Decode Ways },
\hyperref[ Distinct Subsequences ]{ Distinct Subsequences },
\hyperref[ Edit Distance ]{ Edit Distance },
\hyperref[ Generate Parentheses ]{ Generate Parentheses },
\hyperref[ Integer to Roman ]{ Integer to Roman },
\hyperref[ Interleaving String ]{ Interleaving String },
\hyperref[ Length of Last Word ]{ Length of Last Word },
\hyperref[ Letter Combinations of a Phone Number ]{ Letter Combinations of a Phone Number },
\hyperref[ Longest Common Prefix ]{ Longest Common Prefix },
\hyperref[ Longest Palindromic Substring ]{ Longest Palindromic Substring },
\hyperref[ Longest Substring Without Repeating Characters ]{ Longest Substring Without Repeating Characters },
\hyperref[ Longest Valid Parentheses ]{ Longest Valid Parentheses },
\hyperref[ Minimum Window Substring ]{ Minimum Window Substring },
\hyperref[ Multiply Strings ]{ Multiply Strings },
\hyperref[ Regular Expression Matching ]{ Regular Expression Matching },
\hyperref[ Restore IP Addresses ]{ Restore IP Addresses },
\hyperref[ Reverse Words in a String ]{ Reverse Words in a String },
\hyperref[ Roman to Integer ]{ Roman to Integer },
\hyperref[ Scramble String ]{ Scramble String },
\hyperref[ Simplify Path ]{ Simplify Path },
\hyperref[ Substring with Concatenation of All Words ]{ Substring with Concatenation of All Words },
\hyperref[ Text Justification ]{ Text Justification },
\hyperref[ Valid Number ]{ Valid Number },
\hyperref[ Valid Palindrome ]{ Valid Palindrome },
\hyperref[ Valid Parentheses ]{ Valid Parentheses },
\hyperref[ Wildcard Matching ]{ Wildcard Matching },
\hyperref[ Word Ladder II ]{ Word Ladder II },
\hyperref[ ZigZag Conversion ]{ ZigZag Conversion }

\subsection*{ Heap }
\label{ Heap }
\hyperref[ Merge k Sorted Lists ]{ Merge k Sorted Lists }

\subsection*{ Two Pointers }
\label{ Two Pointers }
\hyperref[ 3Sum Closest ]{ 3Sum Closest },
\hyperref[ 3Sum ]{ 3Sum },
\hyperref[ 4Sum ]{ 4Sum },
\hyperref[ Container With Most Water ]{ Container With Most Water },
\hyperref[ Linked List Cycle II ]{ Linked List Cycle II },
\hyperref[ Linked List Cycle ]{ Linked List Cycle },
\hyperref[ Longest Substring Without Repeating Characters ]{ Longest Substring Without Repeating Characters },
\hyperref[ Merge Sorted Array ]{ Merge Sorted Array },
\hyperref[ Minimum Window Substring ]{ Minimum Window Substring },
\hyperref[ Partition List ]{ Partition List },
\hyperref[ Remove Duplicates from Sorted Array II ]{ Remove Duplicates from Sorted Array II },
\hyperref[ Remove Duplicates from Sorted Array ]{ Remove Duplicates from Sorted Array },
\hyperref[ Remove Element ]{ Remove Element },
\hyperref[ Remove Nth Node From End of List ]{ Remove Nth Node From End of List },
\hyperref[ Rotate List ]{ Rotate List },
\hyperref[ Sort Colors ]{ Sort Colors },
\hyperref[ Substring with Concatenation of All Words ]{ Substring with Concatenation of All Words },
\hyperref[ Trapping Rain Water ]{ Trapping Rain Water },
\hyperref[ Valid Palindrome ]{ Valid Palindrome }

\subsection*{ Graph }
\label{ Graph }
\hyperref[ Clone Graph ]{ Clone Graph }

\subsection*{ Tree }
\label{ Tree }
\hyperref[ Balanced Binary Tree ]{ Balanced Binary Tree },
\hyperref[ Binary Search Tree Iterator ]{ Binary Search Tree Iterator },
\hyperref[ Binary Tree Inorder Traversal ]{ Binary Tree Inorder Traversal },
\hyperref[ Binary Tree Level Order Traversal II ]{ Binary Tree Level Order Traversal II },
\hyperref[ Binary Tree Level Order Traversal ]{ Binary Tree Level Order Traversal },
\hyperref[ Binary Tree Maximum Path Sum ]{ Binary Tree Maximum Path Sum },
\hyperref[ Binary Tree Postorder Traversal ]{ Binary Tree Postorder Traversal },
\hyperref[ Binary Tree Preorder Traversal ]{ Binary Tree Preorder Traversal },
\hyperref[ Binary Tree Zigzag Level Order Traversal ]{ Binary Tree Zigzag Level Order Traversal },
\hyperref[ Construct Binary Tree from Inorder and Postorder Traversal ]{ Construct Binary Tree from Inorder and Postorder Traversal },
\hyperref[ Construct Binary Tree from Preorder and Inorder Traversal ]{ Construct Binary Tree from Preorder and Inorder Traversal },
\hyperref[ Convert Sorted Array to Binary Search Tree ]{ Convert Sorted Array to Binary Search Tree },
\hyperref[ Flatten Binary Tree to Linked List ]{ Flatten Binary Tree to Linked List },
\hyperref[ Maximum Depth of Binary Tree ]{ Maximum Depth of Binary Tree },
\hyperref[ Minimum Depth of Binary Tree ]{ Minimum Depth of Binary Tree },
\hyperref[ Path Sum II ]{ Path Sum II },
\hyperref[ Path Sum ]{ Path Sum },
\hyperref[ Populating Next Right Pointers in Each Node II ]{ Populating Next Right Pointers in Each Node II },
\hyperref[ Populating Next Right Pointers in Each Node ]{ Populating Next Right Pointers in Each Node },
\hyperref[ Recover Binary Search Tree ]{ Recover Binary Search Tree },
\hyperref[ Same Tree ]{ Same Tree },
\hyperref[ Sum Root to Leaf Numbers ]{ Sum Root to Leaf Numbers },
\hyperref[ Symmetric Tree ]{ Symmetric Tree },
\hyperref[ Unique Binary Search Trees II ]{ Unique Binary Search Trees II },
\hyperref[ Unique Binary Search Trees ]{ Unique Binary Search Trees },
\hyperref[ Validate Binary Search Tree ]{ Validate Binary Search Tree }

\subsection*{ Greedy }
\label{ Greedy }
\hyperref[ Best Time to Buy and Sell Stock II ]{ Best Time to Buy and Sell Stock II },
\hyperref[ Candy ]{ Candy },
\hyperref[ Gas Station ]{ Gas Station },
\hyperref[ Jump Game II ]{ Jump Game II },
\hyperref[ Jump Game ]{ Jump Game },
\hyperref[ Wildcard Matching ]{ Wildcard Matching }

\subsection*{ Bit Manipulation }
\label{ Bit Manipulation }
\hyperref[ Majority Element ]{ Majority Element },
\hyperref[ Single Number II ]{ Single Number II },
\hyperref[ Single Number ]{ Single Number },
\hyperref[ Subsets ]{ Subsets }

\subsection*{ Linked List }
\label{ Linked List }
\hyperref[ Add Two Numbers ]{ Add Two Numbers },
\hyperref[ Convert Sorted List to Binary Search Tree ]{ Convert Sorted List to Binary Search Tree },
\hyperref[ Copy List with Random Pointer ]{ Copy List with Random Pointer },
\hyperref[ Insertion Sort List ]{ Insertion Sort List },
\hyperref[ Intersection of Two Linked Lists ]{ Intersection of Two Linked Lists },
\hyperref[ Linked List Cycle II ]{ Linked List Cycle II },
\hyperref[ Linked List Cycle ]{ Linked List Cycle },
\hyperref[ Merge k Sorted Lists ]{ Merge k Sorted Lists },
\hyperref[ Merge Two Sorted Lists ]{ Merge Two Sorted Lists },
\hyperref[ Partition List ]{ Partition List },
\hyperref[ Remove Duplicates from Sorted List II ]{ Remove Duplicates from Sorted List II },
\hyperref[ Remove Duplicates from Sorted List ]{ Remove Duplicates from Sorted List },
\hyperref[ Remove Nth Node From End of List ]{ Remove Nth Node From End of List },
\hyperref[ Reorder List ]{ Reorder List },
\hyperref[ Reverse Linked List II ]{ Reverse Linked List II },
\hyperref[ Reverse Nodes in k-Group ]{ Reverse Nodes in k-Group },
\hyperref[ Rotate List ]{ Rotate List },
\hyperref[ Sort List ]{ Sort List },
\hyperref[ Swap Nodes in Pairs ]{ Swap Nodes in Pairs }

\subsection*{ Backtracking }
\label{ Backtracking }
\hyperref[ Combination Sum II ]{ Combination Sum II },
\hyperref[ Combination Sum ]{ Combination Sum },
\hyperref[ Combinations ]{ Combinations },
\hyperref[ Generate Parentheses ]{ Generate Parentheses },
\hyperref[ Gray Code ]{ Gray Code },
\hyperref[ Letter Combinations of a Phone Number ]{ Letter Combinations of a Phone Number },
\hyperref[ N-Queens II ]{ N-Queens II },
\hyperref[ N-Queens ]{ N-Queens },
\hyperref[ Palindrome Partitioning ]{ Palindrome Partitioning },
\hyperref[ Permutation Sequence ]{ Permutation Sequence },
\hyperref[ Permutations II ]{ Permutations II },
\hyperref[ Permutations ]{ Permutations },
\hyperref[ Regular Expression Matching ]{ Regular Expression Matching },
\hyperref[ Restore IP Addresses ]{ Restore IP Addresses },
\hyperref[ Subsets II ]{ Subsets II },
\hyperref[ Subsets ]{ Subsets },
\hyperref[ Sudoku Solver ]{ Sudoku Solver },
\hyperref[ Wildcard Matching ]{ Wildcard Matching },
\hyperref[ Word Break II ]{ Word Break II },
\hyperref[ Word Ladder II ]{ Word Ladder II },
\hyperref[ Word Search ]{ Word Search }

\subsection*{ Hash Table }
\label{ Hash Table }
\hyperref[ 4Sum ]{ 4Sum },
\hyperref[ Anagrams ]{ Anagrams },
\hyperref[ Binary Tree Inorder Traversal ]{ Binary Tree Inorder Traversal },
\hyperref[ Copy List with Random Pointer ]{ Copy List with Random Pointer },
\hyperref[ Fraction to Recurring Decimal ]{ Fraction to Recurring Decimal },
\hyperref[ Longest Substring Without Repeating Characters ]{ Longest Substring Without Repeating Characters },
\hyperref[ Max Points on a Line ]{ Max Points on a Line },
\hyperref[ Maximal Rectangle ]{ Maximal Rectangle },
\hyperref[ Minimum Window Substring ]{ Minimum Window Substring },
\hyperref[ Single Number ]{ Single Number },
\hyperref[ Substring with Concatenation of All Words ]{ Substring with Concatenation of All Words },
\hyperref[ Sudoku Solver ]{ Sudoku Solver },
\hyperref[ Two Sum ]{ Two Sum },
\hyperref[ Valid Sudoku ]{ Valid Sudoku }

\subsection*{ Binary Search }
\label{ Binary Search }
\hyperref[ Divide Two Integers ]{ Divide Two Integers },
\hyperref[ Dungeon Game ]{ Dungeon Game },
\hyperref[ Find Minimum in Rotated Sorted Array II ]{ Find Minimum in Rotated Sorted Array II },
\hyperref[ Find Minimum in Rotated Sorted Array ]{ Find Minimum in Rotated Sorted Array },
\hyperref[ Find Peak Element ]{ Find Peak Element },
\hyperref[ Median of Two Sorted Arrays ]{ Median of Two Sorted Arrays },
\hyperref[ Search a 2D Matrix ]{ Search a 2D Matrix },
\hyperref[ Search for a Range ]{ Search for a Range },
\hyperref[ Search in Rotated Sorted Array II ]{ Search in Rotated Sorted Array II },
\hyperref[ Search in Rotated Sorted Array ]{ Search in Rotated Sorted Array },
\hyperref[ Search Insert Position ]{ Search Insert Position }

\subsection*{ Array }
\label{ Array }
\hyperref[ 3Sum Closest ]{ 3Sum Closest },
\hyperref[ 3Sum ]{ 3Sum },
\hyperref[ 4Sum ]{ 4Sum },
\hyperref[ Best Time to Buy and Sell Stock II ]{ Best Time to Buy and Sell Stock II },
\hyperref[ Best Time to Buy and Sell Stock III ]{ Best Time to Buy and Sell Stock III },
\hyperref[ Best Time to Buy and Sell Stock ]{ Best Time to Buy and Sell Stock },
\hyperref[ Combination Sum II ]{ Combination Sum II },
\hyperref[ Combination Sum ]{ Combination Sum },
\hyperref[ Construct Binary Tree from Inorder and Postorder Traversal ]{ Construct Binary Tree from Inorder and Postorder Traversal },
\hyperref[ Construct Binary Tree from Preorder and Inorder Traversal ]{ Construct Binary Tree from Preorder and Inorder Traversal },
\hyperref[ Container With Most Water ]{ Container With Most Water },
\hyperref[ Find Minimum in Rotated Sorted Array II ]{ Find Minimum in Rotated Sorted Array II },
\hyperref[ Find Minimum in Rotated Sorted Array ]{ Find Minimum in Rotated Sorted Array },
\hyperref[ Find Peak Element ]{ Find Peak Element },
\hyperref[ First Missing Positive ]{ First Missing Positive },
\hyperref[ Insert Interval ]{ Insert Interval },
\hyperref[ Jump Game II ]{ Jump Game II },
\hyperref[ Jump Game ]{ Jump Game },
\hyperref[ Largest Rectangle in Histogram ]{ Largest Rectangle in Histogram },
\hyperref[ Longest Consecutive Sequence ]{ Longest Consecutive Sequence },
\hyperref[ Majority Element ]{ Majority Element },
\hyperref[ Maximal Rectangle ]{ Maximal Rectangle },
\hyperref[ Maximum Product Subarray ]{ Maximum Product Subarray },
\hyperref[ Maximum Subarray ]{ Maximum Subarray },
\hyperref[ Median of Two Sorted Arrays ]{ Median of Two Sorted Arrays },
\hyperref[ Merge Intervals ]{ Merge Intervals },
\hyperref[ Merge Sorted Array ]{ Merge Sorted Array },
\hyperref[ Minimum Path Sum ]{ Minimum Path Sum },
\hyperref[ Next Permutation ]{ Next Permutation },
\hyperref[ Plus One ]{ Plus One },
\hyperref[ Remove Duplicates from Sorted Array II ]{ Remove Duplicates from Sorted Array II },
\hyperref[ Remove Duplicates from Sorted Array ]{ Remove Duplicates from Sorted Array },
\hyperref[ Remove Element ]{ Remove Element },
\hyperref[ Search a 2D Matrix ]{ Search a 2D Matrix },
\hyperref[ Search for a Range ]{ Search for a Range },
\hyperref[ Search in Rotated Sorted Array II ]{ Search in Rotated Sorted Array II },
\hyperref[ Search in Rotated Sorted Array ]{ Search in Rotated Sorted Array },
\hyperref[ Search Insert Position ]{ Search Insert Position },
\hyperref[ Set Matrix Zeroes ]{ Set Matrix Zeroes },
\hyperref[ Sort Colors ]{ Sort Colors },
\hyperref[ Spiral Matrix II ]{ Spiral Matrix II },
\hyperref[ Spiral Matrix ]{ Spiral Matrix },
\hyperref[ Subsets II ]{ Subsets II },
\hyperref[ Subsets ]{ Subsets },
\hyperref[ Trapping Rain Water ]{ Trapping Rain Water },
\hyperref[ Triangle ]{ Triangle },
\hyperref[ Two Sum ]{ Two Sum },
\hyperref[ Unique Paths II ]{ Unique Paths II },
\hyperref[ Unique Paths ]{ Unique Paths },
\hyperref[ Word Ladder II ]{ Word Ladder II },
\hyperref[ Word Search ]{ Word Search }

\subsection*{ Depth-first Search }
\label{ Depth-first Search }
\hyperref[ Balanced Binary Tree ]{ Balanced Binary Tree },
\hyperref[ Binary Tree Maximum Path Sum ]{ Binary Tree Maximum Path Sum },
\hyperref[ Clone Graph ]{ Clone Graph },
\hyperref[ Construct Binary Tree from Inorder and Postorder Traversal ]{ Construct Binary Tree from Inorder and Postorder Traversal },
\hyperref[ Construct Binary Tree from Preorder and Inorder Traversal ]{ Construct Binary Tree from Preorder and Inorder Traversal },
\hyperref[ Convert Sorted Array to Binary Search Tree ]{ Convert Sorted Array to Binary Search Tree },
\hyperref[ Convert Sorted List to Binary Search Tree ]{ Convert Sorted List to Binary Search Tree },
\hyperref[ Flatten Binary Tree to Linked List ]{ Flatten Binary Tree to Linked List },
\hyperref[ Maximum Depth of Binary Tree ]{ Maximum Depth of Binary Tree },
\hyperref[ Minimum Depth of Binary Tree ]{ Minimum Depth of Binary Tree },
\hyperref[ Path Sum II ]{ Path Sum II },
\hyperref[ Path Sum ]{ Path Sum },
\hyperref[ Populating Next Right Pointers in Each Node II ]{ Populating Next Right Pointers in Each Node II },
\hyperref[ Populating Next Right Pointers in Each Node ]{ Populating Next Right Pointers in Each Node },
\hyperref[ Recover Binary Search Tree ]{ Recover Binary Search Tree },
\hyperref[ Same Tree ]{ Same Tree },
\hyperref[ Sum Root to Leaf Numbers ]{ Sum Root to Leaf Numbers },
\hyperref[ Symmetric Tree ]{ Symmetric Tree },
\hyperref[ Validate Binary Search Tree ]{ Validate Binary Search Tree }

\subsection*{ Stack }
\label{ Stack }
\hyperref[ Binary Search Tree Iterator ]{ Binary Search Tree Iterator },
\hyperref[ Binary Tree Inorder Traversal ]{ Binary Tree Inorder Traversal },
\hyperref[ Binary Tree Postorder Traversal ]{ Binary Tree Postorder Traversal },
\hyperref[ Binary Tree Preorder Traversal ]{ Binary Tree Preorder Traversal },
\hyperref[ Binary Tree Zigzag Level Order Traversal ]{ Binary Tree Zigzag Level Order Traversal },
\hyperref[ Evaluate Reverse Polish Notation ]{ Evaluate Reverse Polish Notation },
\hyperref[ Largest Rectangle in Histogram ]{ Largest Rectangle in Histogram },
\hyperref[ Maximal Rectangle ]{ Maximal Rectangle },
\hyperref[ Min Stack ]{ Min Stack },
\hyperref[ Simplify Path ]{ Simplify Path },
\hyperref[ Trapping Rain Water ]{ Trapping Rain Water },
\hyperref[ Valid Parentheses ]{ Valid Parentheses }

\subsection*{ Math }
\label{ Math }
\hyperref[ Add Binary ]{ Add Binary },
\hyperref[ Add Two Numbers ]{ Add Two Numbers },
\hyperref[ Divide Two Integers ]{ Divide Two Integers },
\hyperref[ Excel Sheet Column Number ]{ Excel Sheet Column Number },
\hyperref[ Excel Sheet Column Title ]{ Excel Sheet Column Title },
\hyperref[ Factorial Trailing Zeroes ]{ Factorial Trailing Zeroes },
\hyperref[ Fraction to Recurring Decimal ]{ Fraction to Recurring Decimal },
\hyperref[ Integer to Roman ]{ Integer to Roman },
\hyperref[ Max Points on a Line ]{ Max Points on a Line },
\hyperref[ Multiply Strings ]{ Multiply Strings },
\hyperref[ Palindrome Number ]{ Palindrome Number },
\hyperref[ Permutation Sequence ]{ Permutation Sequence },
\hyperref[ Plus One ]{ Plus One },
\hyperref[ Reverse Integer ]{ Reverse Integer },
\hyperref[ Roman to Integer ]{ Roman to Integer },
\hyperref[ Valid Number ]{ Valid Number }

\subsection*{ Breadth-first Search }
\label{ Breadth-first Search }
\hyperref[ Binary Tree Level Order Traversal II ]{ Binary Tree Level Order Traversal II },
\hyperref[ Binary Tree Level Order Traversal ]{ Binary Tree Level Order Traversal },
\hyperref[ Binary Tree Zigzag Level Order Traversal ]{ Binary Tree Zigzag Level Order Traversal },
\hyperref[ Clone Graph ]{ Clone Graph },
\hyperref[ Surrounded Regions ]{ Surrounded Regions },
\hyperref[ Word Ladder II ]{ Word Ladder II },
\hyperref[ Word Ladder ]{ Word Ladder }
\section{Solutions of leetcode algorithm problems}

\subsection{ 3Sum Closest }
\label{ 3Sum Closest }

\subsubsection*{Problem Description}
Given an array \emph{S} of \emph{n} integers, find three integers in \emph{S} such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.

\begin{verbatim}
    For example, given array S = {-1 2 1 -4}, and target = 1.

    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
\end{verbatim}

\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Two Pointers ]{ Two Pointers }


\rightline{\href{https://oj.leetcode.com/problems/3sum-closest/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int threeSumClosest(vector<int> &num, int target) {
        if (num.size() < 3) return 0;
        int ans = num[0] + num[1] + num[2], temp;
        sort(num.begin(), num.end());
        for (int i = 0; i < num.size(); ++i) {
            int j = i + 1, k = num.size() - 1;
            while(j < k) {
                while (j < k && num[i] + num[j] + num[k] >= target) {
                    if (abs(ans - target) > abs((temp = num[i] + num[j] + num[k]) - target)) {
                        ans = temp;
                    }
                    -- k;
                }
                while (j < k && num[i] + num[j] + num[k] <= target) {
                    if (abs(ans - target) > abs((temp = num[i] + num[j] + num[k]) - target)) {
                        ans = temp;
                    }
                    ++ j;
                }
            }
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ 3Sum }
\label{ 3Sum }

\subsubsection*{Problem Description}
Given an array \emph{S} of \emph{n} integers, are there elements \emph{a}, \emph{b}, \emph{c} in \emph{S} such that \emph{a} + \emph{b} + \emph{c} = 0? Find all unique triplets in the array which gives the sum of zero.

\textbf{Note:}


\begin{itemize}
\item Elements in a triplet (\emph{a},\emph{b},\emph{c}) must be in non-descending order. (ie, \emph{a} ≤ \emph{b} ≤ \emph{c})
\item The solution set must not contain duplicate triplets.
\end{itemize}

\begin{verbatim}
    For example, given array S = {-1 0 1 2 -1 -4},

    A solution set is:
    (-1, 0, 1)
    (-1, -1, 2)
\end{verbatim}

\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Two Pointers ]{ Two Pointers }


\rightline{\href{https://oj.leetcode.com/problems/3sum/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<vector<int> > threeSum(vector<int> &num) {
        vector<vector<int> > ans;
        vector<int> triplet(3);
        sort(num.begin(), num.end());
        int i = 0;
        do {
            int j = i + 1, k = num.size() - 1;
            do {
                while(j < k && num[i] + num[j] + num[k] > 0) {
                    -- k;
                } 
                if (j < k && num[i] + num[j] + num[k] == 0) {
                    triplet[0] = num[i], 
                    triplet[1] = num[j], 
                    triplet[2] = num[k], 
                    ans.push_back(triplet);
                }
                ++ j;
                while(j < k && num[j] == num[j - 1]) ++j;
            } while (j < k);
            ++ i;
            while (i < num.size() && num[i] == num[i - 1]) ++i;
        } while (i < num.size());
        
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ 4Sum }
\label{ 4Sum }

\subsubsection*{Problem Description}
Given an array \emph{S} of \emph{n} integers, are there elements \emph{a}, \emph{b}, \emph{c}, and \emph{d} in \emph{S} such that \emph{a} + \emph{b} + \emph{c} + \emph{d} = target? Find all unique quadruplets in the array which gives the sum of target.

\textbf{Note:}


\begin{itemize}
\item Elements in a quadruplet (\emph{a},\emph{b},\emph{c},\emph{d}) must be in non-descending order. (ie, \emph{a} ≤ \emph{b} ≤ \emph{c} ≤ \emph{d})
\item The solution set must not contain duplicate quadruplets.
\end{itemize}

\begin{verbatim}
    For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

    A solution set is:
    (-1,  0, 0, 1)
    (-2, -1, 1, 2)
    (-2,  0, 0, 2)
\end{verbatim}

\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Hash Table ]{ Hash Table },  \hyperref[ Two Pointers ]{ Two Pointers }


\rightline{\href{https://oj.leetcode.com/problems/4sum/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<vector<int> > fourSum(vector<int> &num, int target) {
        int n = num.size();
        vector<vector<int> > ans;
        if (n < 4) return ans;
        vector<int> next(n, n), pre(n, -1);
        sort(num.begin(), num.end());
        for (int i = n - 2; i >= 0; --i) {
            if (num[i] == num[i + 1]) {
                next[i] = next[i + 1];
            } else {
                next[i] = i + 1;
            }
        }
        for (int i = 1; i < n; ++i) {
            if (num[i] == num[i - 1]) {
                pre[i] = pre[i - 1];
            } else {
                pre[i] = i - 1;
            }
        }
        for (int i = 0; i < n; i = next[i]) {
            for (int j = i + 1; j < n; j = next[j]) {
                int p = j + 1, q = n - 1;
                while (p < q) {
                    while (p < q && num[i] + num[j] + num[p] + num[q] != target) {
                        if (num[i] + num[j] + num[p] + num[q] < target) {
                            p = next[p];
                        } else {
                            q = pre[q];
                        }
                    }
                    if (p < q) {
                        ans.push_back(quadruplets(num[i], num[j], num[p], num[q]));
                        p = next[p];
                    }
                }
            }
        }
        return ans;
    }
private:
    vector<int> quadruplets(int a, int b, int c, int d) {
        vector<int> replets;
        replets.push_back(a);
        replets.push_back(b);
        replets.push_back(c);
        replets.push_back(d);
        return replets;
    }
}; 
\end{lstlisting}


\subsection{ Add Binary }
\label{ Add Binary }

\subsubsection*{Problem Description}
Given two binary strings, return their sum (also a binary string).

For example,


a = \textbf{"11"}


b = \textbf{"1"}


Return \textbf{"100"}.


\textbf{Tags: }
\hyperref[ Math ]{ Math },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/add-binary/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    string addBinary(string a, string b) {
        string sum;
        int c = 0;
        for (int i = 0; i < a.size() || i < b.size(); ++i) {
            if (i < a.size()) {
                c += a[a.size() - 1 - i] - '0';
            }
            if (i < b.size()) {
                c += b[b.size() - 1 - i] - '0';
            }
            sum.push_back(c % 2 + '0');
            c /= 2;
        }
        if (c) {
            sum.push_back('1');
        }
        return string(sum.rbegin(), sum.rend());
    }
}; 
\end{lstlisting}


\subsection{ Add Two Numbers }
\label{ Add Two Numbers }

\subsubsection*{Problem Description}
You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.


\textbf{Tags: }
\hyperref[ Linked List ]{ Linked List },  \hyperref[ Math ]{ Math }


\rightline{\href{https://oj.leetcode.com/problems/add-two-numbers/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        if (l1 == NULL && l2 == NULL) return NULL;
        ListNode head(0), *p;
        int c = 0;
        p = &head;
        while(l1 || l2) {
            if (l1) {
                c += l1->val;
                l1 = l1->next;
            }
            if (l2) {
                c += l2->val;
                l2 = l2->next;
            }
            p->next = new ListNode(c % 10);
            p = p->next;
            c /= 10;
        }
        if (c) {
            p->next = new ListNode(c);
        }
        return head.next;
    }
}; 
\end{lstlisting}


\subsection{ Anagrams }
\label{ Anagrams }

\subsubsection*{Problem Description}
Given an array of strings, return all groups of strings that are anagrams.

Note: All inputs will be in lower-case.


\textbf{Tags: }
\hyperref[ Hash Table ]{ Hash Table },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/anagrams/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<string> anagrams(vector<string> &strs) {
        vector<string> ans;
        map<string, int> cnt;
        for (int i = 0; i < strs.size(); ++i) {
            string s = strs[i];
            sort(s.begin(), s.end());
            if (cnt.find(s) == cnt.end()) {
                cnt[s] = 1;
            } else {
                ++ cnt[s];
            }
        }
        for (int i = 0; i < strs.size(); ++i) {
            string s = strs[i];
            sort(s.begin(), s.end());
            if (cnt[s] >= 2) {
                ans.push_back(strs[i]);
            }
        }
        return ans;
    }
};

\end{lstlisting}


\subsection{ Balanced Binary Tree }
\label{ Balanced Binary Tree }

\subsubsection*{Problem Description}
Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of \emph{every} node never differ by more than 1.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Depth-first Search ]{ Depth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/balanced-binary-tree/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isBalanced(TreeNode *root) {
        int depth;
        return _isBalanced(root, depth);
    }
private:
    bool _isBalanced(TreeNode *root, int &depth) {
        if (root == NULL) {
            depth = 0;
            return true;
        }
        int leftdepth, rightdepth;
        if (_isBalanced(root->left, leftdepth) && _isBalanced(root->right, rightdepth)) {
            depth = max(leftdepth, rightdepth) + 1;
            return abs(leftdepth - rightdepth) <= 1;
        }
        return false;
    }
}; 
\end{lstlisting}


\subsection{ Best Time to Buy and Sell Stock II }
\label{ Best Time to Buy and Sell Stock II }

\subsubsection*{Problem Description}
Say you have an array for which the \emph{i}th element is the price of a given stock on day \emph{i}.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Greedy ]{ Greedy }


\rightline{\href{https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int maxProfit(vector<int> &prices) {
        if (prices.size() <= 1) return 0;
        int f[prices.size()][2];
        f[0][0] = 0, f[0][1] = -prices[0];;
        for (int i = 1; i < prices.size(); ++i) {
            f[i][0] = max(f[i - 1][0], f[i - 1][1] + prices[i]);
            f[i][1] = max(f[i - 1][1], f[i - 1][0] - prices[i]);
        }
        return f[prices.size() - 1][0];
    }
}; 
\end{lstlisting}


\subsection{ Best Time to Buy and Sell Stock III }
\label{ Best Time to Buy and Sell Stock III }

\subsubsection*{Problem Description}
Say you have an array for which the \emph{i}th element is the price of a given stock on day \emph{i}.

Design an algorithm to find the maximum profit. You may complete at most \emph{two} transactions.

\textbf{Note:}


You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Dynamic Programming ]{ Dynamic Programming }


\rightline{\href{https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int maxProfit(vector<int> &prices) {
        int n = prices.size();
        if (n <= 1) return 0;
        vector<vector<int> > f(n + 1, vector<int>(5, 0));
        f[0][1] = f[0][3] = -prices[0];
        for (int i = 1; i <= prices.size(); ++i) {
            f[i][0] = f[i - 1][0];
            f[i][1] = max(f[i][0] - prices[i - 1], f[i - 1][1]);
            f[i][2] = max(f[i][1] + prices[i - 1], f[i - 1][2]);
            f[i][3] = max(f[i][2] - prices[i - 1], f[i - 1][3]);
            f[i][4] = max(f[i][3] + prices[i - 1], f[i - 1][4]);
        }
        return f[n][4];
    }
};

\end{lstlisting}


\subsection{ Best Time to Buy and Sell Stock }
\label{ Best Time to Buy and Sell Stock }

\subsubsection*{Problem Description}
Say you have an array for which the \emph{i}th element is the price of a given stock on day \emph{i}.

If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Dynamic Programming ]{ Dynamic Programming }


\rightline{\href{https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int maxProfit(vector<int> &prices) {
        if (prices.size() <= 1) return 0;
        int minprice = prices[0], ans = 0;
        for (int i = 1; i < prices.size(); ++i) {
            ans = max(ans, prices[i] - minprice);
            minprice = min(minprice, prices[i]);
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Binary Search Tree Iterator }
\label{ Binary Search Tree Iterator }

\subsubsection*{Problem Description}
Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

Calling \textbf{next()} will return the next smallest number in the BST.

\textbf{Note: }\textbf{next()} and \textbf{hasNext()} should run in average O(1) time and uses O(\emph{h}) memory, where \emph{h} is the height of the tree.

\textbf{Credits:}

Special thanks to @ts for adding this problem and creating all test cases.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Stack ]{ Stack }


\rightline{\href{https://oj.leetcode.com/problems/binary-search-tree-iterator/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class BSTIterator {
public:
    BSTIterator(TreeNode *root) {
        while (root) {
            path.push_back(root);
            root = root->left;
        }
    }
    
    /** @return whether we have a next smallest number */
    bool hasNext() {
        return path.size() != 0;
    }
    
    /** @return the next smallest number */
    int next() {
        TreeNode *ptr = path[path.size() - 1];
        int value = ptr->val;
        if (ptr->right) {
            ptr = ptr->right;
            path.push_back(ptr);
            while (ptr->left) {
                ptr = ptr->left;
                path.push_back(ptr);
            }
        } else {
            while (path.size() >= 2 && path[path.size() - 2]->right == path[path.size() - 1]) {
                path.pop_back();
            }
            path.pop_back();
        }
        return value;
    }
private:
    vector<TreeNode*> path;
};

/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = BSTIterator(root);
 * while (i.hasNext()) cout << i.next();
 */

\end{lstlisting}


\subsection{ Binary Tree Inorder Traversal }
\label{ Binary Tree Inorder Traversal }

\subsubsection*{Problem Description}
Given a binary tree, return the \emph{inorder} traversal of its nodes' values.

For example:


Given binary tree \textbf{\{1,\#,2,3\}},


\begin{verbatim}
   1
    \
     2
    /
   3
\end{verbatim}

return \textbf{[1,3,2]}.

\textbf{Note:} Recursive solution is trivial, could you do it iteratively?

The serialization of a binary tree follows a level order traversal, where '\#' signifies a path terminator where no node exists below.

Here's an example:


\begin{verbatim}
   1
  / \
 2   3
    /
   4
    \
     5
\end{verbatim}
The above binary tree is serialized as \textbf{"\{1,2,3,\#,\#,4,\#,\#,5\}"}.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Hash Table ]{ Hash Table },  \hyperref[ Stack ]{ Stack }


\rightline{\href{https://oj.leetcode.com/problems/binary-tree-inorder-traversal/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode *root) {
        vector<int> ans;
        inorderTraversal(root, ans);
        return ans;
    }
private:
    void inorderTraversal(TreeNode *root, vector<int> & ans) {
        if (root == NULL) return ;
        inorderTraversal(root->left, ans);
        ans.push_back(root->val);
        inorderTraversal(root->right, ans);
    }
}; 
\end{lstlisting}


\subsection{ Binary Tree Level Order Traversal II }
\label{ Binary Tree Level Order Traversal II }

\subsubsection*{Problem Description}
Given a binary tree, return the \emph{bottom-up level order} traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

For example:


Given binary tree \textbf{\{3,9,20,\#,\#,15,7\}},


\begin{verbatim}
    3
   / \
  9  20
    /  \
   15   7
\end{verbatim}

return its bottom-up level order traversal as:


\begin{verbatim}
[
  [15,7],
  [9,20],
  [3]
]
\end{verbatim}

The serialization of a binary tree follows a level order traversal, where '\#' signifies a path terminator where no node exists below.

Here's an example:


\begin{verbatim}
   1
  / \
 2   3
    /
   4
    \
     5
\end{verbatim}
The above binary tree is serialized as \textbf{"\{1,2,3,\#,\#,4,\#,\#,5\}"}.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Breadth-first Search ]{ Breadth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int> > levelOrderBottom(TreeNode *root) {
        vector<vector<int> > ans;
        if (root == NULL) return ans;
        vector<int> nowval;
        vector<TreeNode *> up, now;
        now.push_back(root);
        while (now.size()){
            nowval.clear();
            for (int i = 0; i < now.size(); ++i) {
                nowval.push_back(now[i]->val);
            }
            ans.push_back(nowval);
            up = now;
            now.clear();
            for (int i = 0; i < up.size(); ++i) {
                if (up[i]->left) {
                    now.push_back(up[i]->left);
                }
                if (up[i]->right) {
                    now.push_back(up[i]->right);
                }
            }
        }
        return vector<vector<int> > (ans.rbegin(), ans.rend());
    }
}; 
\end{lstlisting}


\subsection{ Binary Tree Level Order Traversal }
\label{ Binary Tree Level Order Traversal }

\subsubsection*{Problem Description}
Given a binary tree, return the \emph{level order} traversal of its nodes' values. (ie, from left to right, level by level).

For example:


Given binary tree \textbf{\{3,9,20,\#,\#,15,7\}},


\begin{verbatim}
    3
   / \
  9  20
    /  \
   15   7
\end{verbatim}

return its level order traversal as:


\begin{verbatim}
[
  [3],
  [9,20],
  [15,7]
]
\end{verbatim}

The serialization of a binary tree follows a level order traversal, where '\#' signifies a path terminator where no node exists below.

Here's an example:


\begin{verbatim}
   1
  / \
 2   3
    /
   4
    \
     5
\end{verbatim}
The above binary tree is serialized as \textbf{"\{1,2,3,\#,\#,4,\#,\#,5\}"}.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Breadth-first Search ]{ Breadth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/binary-tree-level-order-traversal/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int> > levelOrder(TreeNode *root) {
        vector<vector<int> > ans;
        if (root == NULL) return ans;
        vector<int> nowval;
        vector<TreeNode *> up, now;
        now.push_back(root);
        while (now.size()){
            nowval.clear();
            for (int i = 0; i < now.size(); ++i) {
                nowval.push_back(now[i]->val);
            }
            ans.push_back(nowval);
            up = now;
            now.clear();
            for (int i = 0; i < up.size(); ++i) {
                if (up[i]->left) {
                    now.push_back(up[i]->left);
                }
                if (up[i]->right) {
                    now.push_back(up[i]->right);
                }
            }
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Binary Tree Maximum Path Sum }
\label{ Binary Tree Maximum Path Sum }

\subsubsection*{Problem Description}
Given a binary tree, find the maximum path sum.

The path may start and end at any node in the tree.

For example:


Given the below binary tree,
\begin{verbatim}
       1
      / \
     2   3
\end{verbatim}

Return \textbf{6}.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Depth-first Search ]{ Depth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/binary-tree-maximum-path-sum/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxPathSum(TreeNode *root) {
        if (root == NULL) return 0;
        int ans = root->val;
        maxPath(root, ans);
        return ans;
    }
private:
    int maxPath(TreeNode *root, int &ans) {
        if (root == NULL) return 0;
        int leftPath = max(maxPath(root->left, ans), 0);
        int rightPath = max(maxPath(root->right, ans), 0);
        ans = max(leftPath + rightPath + root->val, ans);
        return max(leftPath, rightPath) + root->val;
    }
}; 
\end{lstlisting}


\subsection{ Binary Tree Postorder Traversal }
\label{ Binary Tree Postorder Traversal }

\subsubsection*{Problem Description}
Given a binary tree, return the \emph{postorder} traversal of its nodes' values.

For example:


Given binary tree \textbf{\{1,\#,2,3\}},


\begin{verbatim}
   1
    \
     2
    /
   3
\end{verbatim}

return \textbf{[3,2,1]}.

\textbf{Note:} Recursive solution is trivial, could you do it iteratively?


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Stack ]{ Stack }


\rightline{\href{https://oj.leetcode.com/problems/binary-tree-postorder-traversal/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode *root) {
        vector<int> nodes;
        postorderTraversal(root, nodes);
        return nodes;
    }
private:
    void postorderTraversal(TreeNode *root, vector<int> &nodes) {
        if (root == NULL) return;
        postorderTraversal(root->left, nodes);
        postorderTraversal(root->right, nodes);
        nodes.push_back(root->val);
    }
}; 
\end{lstlisting}


\subsection{ Binary Tree Preorder Traversal }
\label{ Binary Tree Preorder Traversal }

\subsubsection*{Problem Description}
Given a binary tree, return the \emph{preorder} traversal of its nodes' values.

For example:


Given binary tree \textbf{\{1,\#,2,3\}},


\begin{verbatim}
   1
    \
     2
    /
   3
\end{verbatim}

return \textbf{[1,2,3]}.

\textbf{Note:} Recursive solution is trivial, could you do it iteratively?


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Stack ]{ Stack }


\rightline{\href{https://oj.leetcode.com/problems/binary-tree-preorder-traversal/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode *root) {
        vector<int> nodes;
        preorderTraversal(root, nodes);
        return nodes;
    }
private:
    void preorderTraversal(TreeNode *root, vector<int> &nodes) {
        if (root == NULL) return;
        nodes.push_back(root->val);
        preorderTraversal(root->left, nodes);
        preorderTraversal(root->right, nodes);
    }
}; 
\end{lstlisting}


\subsection{ Binary Tree Zigzag Level Order Traversal }
\label{ Binary Tree Zigzag Level Order Traversal }

\subsubsection*{Problem Description}
Given a binary tree, return the \emph{zigzag level order} traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:


Given binary tree \textbf{\{3,9,20,\#,\#,15,7\}},


\begin{verbatim}
    3
   / \
  9  20
    /  \
   15   7
\end{verbatim}

return its zigzag level order traversal as:


\begin{verbatim}
[
  [3],
  [20,9],
  [15,7]
]
\end{verbatim}

The serialization of a binary tree follows a level order traversal, where '\#' signifies a path terminator where no node exists below.

Here's an example:


\begin{verbatim}
   1
  / \
 2   3
    /
   4
    \
     5
\end{verbatim}
The above binary tree is serialized as \textbf{"\{1,2,3,\#,\#,4,\#,\#,5\}"}.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Breadth-first Search ]{ Breadth-first Search },  \hyperref[ Stack ]{ Stack }


\rightline{\href{https://oj.leetcode.com/problems/binary-tree-zigzag-level-order-traversal/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int> > zigzagLevelOrder(TreeNode *root) {
        vector<vector<int> > ans;
        if (root == NULL) return ans;
        vector<int> nowval;
        vector<TreeNode *> up, now;
        now.push_back(root);
        int level = 0;
        while (now.size()){
            nowval.clear();
            for (int i = 0; i < now.size(); ++i) {
                nowval.push_back(now[i]->val);
            }
            ++ level;
            if (level % 2 == 1) {
                ans.push_back(nowval);
            } else {
                ans.push_back(vector<int> (nowval.rbegin(), nowval.rend()));
            }
            up = now;
            now.clear();
            for (int i = 0; i < up.size(); ++i) {
                if (up[i]->left) {
                    now.push_back(up[i]->left);
                }
                if (up[i]->right) {
                    now.push_back(up[i]->right);
                }
            }
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Candy }
\label{ Candy }

\subsubsection*{Problem Description}
There are \emph{N} children standing in a line. Each child is assigned a rating value.

You are giving candies to these children subjected to the following requirements:

What is the minimum candies you must give?


\textbf{Tags: }
\hyperref[ Greedy ]{ Greedy }


\rightline{\href{https://oj.leetcode.com/problems/candy/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int candy(vector<int> &ratings) {
        vector<int> c(ratings.size(), 1);
        for(int i = 1; i < c.size(); ++i) {
            if (ratings[i] > ratings[i - 1]) {
                c[i] = c[i - 1] + 1;
            }
        }
        for (int i = c.size() - 1; i; --i) {
            if (ratings[i - 1] > ratings[i]) {
                c[i - 1] = max(c[i - 1], c[i] + 1);
            }
        }
        int ans = 0;
        for (int i = 0; i < c.size(); ++i) {
            ans += c[i];
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Climbing Stairs }
\label{ Climbing Stairs }

\subsubsection*{Problem Description}
You are climbing a stair case. It takes \emph{n} steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?


\textbf{Tags: }
\hyperref[ Dynamic Programming ]{ Dynamic Programming }


\rightline{\href{https://oj.leetcode.com/problems/climbing-stairs/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int climbStairs(int n) {
        int f[n + 1];
        f[0] = f[1] = 1;
        for (int i = 2; i <= n; ++i) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f[n];
    }
}; 
\end{lstlisting}


\subsection{ Clone Graph }
\label{ Clone Graph }

\subsubsection*{Problem Description}
Clone an undirected graph. Each node in the graph contains a \textbf{label} and a list of its \textbf{neighbors}.

Nodes are labeled uniquely.

As an example, consider the serialized graph \textbf{\{0,1,2\#1,2\#2,2\}}.

The graph has a total of three nodes, and therefore contains three parts as separated by \textbf{\#}.

First node is labeled as \textbf{0}. Connect node \textbf{0} to both nodes \textbf{1} and \textbf{2}.
Second node is labeled as \textbf{1}. Connect node \textbf{1} to node \textbf{2}.
Third node is labeled as \textbf{2}. Connect node \textbf{2} to node \textbf{2} (itself), thus forming a self-cycle.
\begin{itemize}
\item First node is labeled as \textbf{0}. Connect node \textbf{0} to both nodes \textbf{1} and \textbf{2}.
\item Second node is labeled as \textbf{1}. Connect node \textbf{1} to node \textbf{2}.
\item Third node is labeled as \textbf{2}. Connect node \textbf{2} to node \textbf{2} (itself), thus forming a self-cycle.
\end{itemize}

Visually, the graph looks like the following:
\begin{verbatim}
       1
      / \
     /   \
    0 --- 2
         / \
         \\_/
\end{verbatim}


\textbf{Tags: }
\hyperref[ Depth-first Search ]{ Depth-first Search },  \hyperref[ Breadth-first Search ]{ Breadth-first Search },  \hyperref[ Graph ]{ Graph }


\rightline{\href{https://oj.leetcode.com/problems/clone-graph/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for undirected graph.
 * struct UndirectedGraphNode {
 *     int label;
 *     vector<UndirectedGraphNode *> neighbors;
 *     UndirectedGraphNode(int x) : label(x) {};
 * };
 */
class Solution {
public:
    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
        if (node == NULL) return NULL;
        pmap.clear();
        return _cloneGraph(node);
    }
private:
    UndirectedGraphNode * _cloneGraph(UndirectedGraphNode *node) {
        if (pmap.find(node) != pmap.end()) {
            return pmap[node];
        }
        UndirectedGraphNode *newnode = new UndirectedGraphNode(node->label);
        pmap[node] = newnode;
        for (int i = 0; i < node->neighbors.size(); ++i) {
            newnode->neighbors.push_back(_cloneGraph(node->neighbors[i]));
        }
        return newnode;
    }
    map<UndirectedGraphNode *, UndirectedGraphNode *> pmap;
}; 
\end{lstlisting}


\subsection{ Combination Sum II }
\label{ Combination Sum II }

\subsubsection*{Problem Description}
Given a collection of candidate numbers (\textbf{\emph{C}}) and a target number (\textbf{\emph{T}}), find all unique combinations in \textbf{\emph{C}} where the candidate numbers sums to \textbf{\emph{T}}.

Each number in \textbf{\emph{C}} may only be used \textbf{once} in the combination.

\textbf{Note:}


\begin{itemize}
\item All numbers (including target) will be positive integers.
\item Elements in a combination (\emph{a}1, \emph{a}2, … , \emph{a}k) must be in non-descending order. (ie, \emph{a}1 ≤ \emph{a}2 ≤ … ≤ \emph{a}k).
\item The solution set must not contain duplicate combinations.
\end{itemize}

For example, given candidate set \textbf{10,1,2,7,6,1,5} and target \textbf{8}, 


A solution set is: 


\textbf{[1, 7]} 


\textbf{[1, 2, 5]} 


\textbf{[2, 6]} 


\textbf{[1, 1, 6]}


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Backtracking ]{ Backtracking }


\rightline{\href{https://oj.leetcode.com/problems/combination-sum-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<vector<int> > combinationSum2(vector<int> &num, int target) {
        int n = num.size();
        ans.clear();
        select.clear();
        if (n == 0) return ans;
        sort(num.rbegin(), num.rend());
        int c[n];
        for (int i = 0; i < n; ++i) {
            c[i] = num[i];
        }
        _gen(c, 0, n, target);
        return ans;
    }
private:
    void _gen(int c[], int k, int n, int target, bool last = true) {
        if (n == k) {
            if(target == 0) {
                vector<int> onec(select.rbegin(), select.rend());
                ans.push_back(onec);
            }
            return ;
        }
        
        if (!(last == false && c[k] == c[k - 1]) && c[k] <= target) {
            select.push_back(c[k]);
            _gen(c, k + 1, n, target - c[k], true);
            select.pop_back();
        }
        
        _gen(c, k + 1, n, target, false);
    }
    vector<vector<int> >  ans;
    vector<int> select;
}; 
\end{lstlisting}


\subsection{ Combination Sum }
\label{ Combination Sum }

\subsubsection*{Problem Description}
Given a set of candidate numbers (\textbf{\emph{C}}) and a target number (\textbf{\emph{T}}), find all unique combinations in \textbf{\emph{C}} where the candidate numbers sums to \textbf{\emph{T}}.

The \textbf{same} repeated number may be chosen from \textbf{\emph{C}} unlimited number of times.

\textbf{Note:}


\begin{itemize}
\item All numbers (including target) will be positive integers.
\item Elements in a combination (\emph{a}1, \emph{a}2, … , \emph{a}k) must be in non-descending order. (ie, \emph{a}1 ≤ \emph{a}2 ≤ … ≤ \emph{a}k).
\item The solution set must not contain duplicate combinations.
\end{itemize}

For example, given candidate set \textbf{2,3,6,7} and target \textbf{7}, 


A solution set is: 


\textbf{[7]} 


\textbf{[2, 2, 3]}


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Backtracking ]{ Backtracking }


\rightline{\href{https://oj.leetcode.com/problems/combination-sum/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<vector<int> > combinationSum(vector<int> &candidates, int target) {
        int n = candidates.size();
        sort(candidates.rbegin(), candidates.rend());
        int c[n], m = 0;
        c[m++] = candidates[0];
        for (int i = 1; i < n; ++i) {
            if (candidates[i] != candidates[i - 1]) c[m++] = candidates[i];
        }
        ans.clear();
        select.clear();
        _gen(c, m, target);
        return ans;
    }
private:
    void _gen(int c[], int n, int target) {
        if (n == 0) {
            if(target == 0) {
                vector<int> onec(select.rbegin(), select.rend());
                ans.push_back(onec);
            }
            return ;
        }
        int times = 0;
        
        while(c[0] * ++times <= target) {
            select.push_back(c[0]);
            _gen(c + 1, n - 1, target - c[0] * times);
        }
        
        for (int i = 1; i < times; ++i) {
            select.pop_back();
        }
        _gen(c + 1, n - 1, target);
    }
    vector<vector<int> >  ans;
    vector<int> select;
};

\end{lstlisting}


\subsection{ Combinations }
\label{ Combinations }

\subsubsection*{Problem Description}
Given two integers \emph{n} and \emph{k}, return all possible combinations of \emph{k} numbers out of 1 ... \emph{n}.

For example,


If \emph{n} = 4 and \emph{k} = 2, a solution is:

\begin{verbatim}
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
\end{verbatim}

\textbf{Tags: }
\hyperref[ Backtracking ]{ Backtracking }


\rightline{\href{https://oj.leetcode.com/problems/combinations/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<vector<int> > combine(int n, int k) {
        ans.clear();
        select.clear();
        _gen(k, n, 0);
        return  ans;
    }
private:
    void _gen(int k, int n, int last) {
        if (select.size() == k) {
            ans.push_back(select);
            return ;
        }
        for (int i = last + 1; i <= n; ++i) {
            select.push_back(i);
            _gen(k, n, i);
            select.pop_back();
        }
    }
    vector<int> select;
    vector<vector<int> > ans;
}; 
\end{lstlisting}


\subsection{ Compare Version Numbers }
\label{ Compare Version Numbers }

\subsubsection*{Problem Description}
Compare two version numbers \emph{version1} and \emph{version1}.


If \emph{version1} $>$ \emph{version2} return 1, if \emph{version1} $<$ \emph{version2} return -1, otherwise return 0.

You may assume that the version strings are non-empty and contain only digits and the \textbf{.} character.


The \textbf{.} character does not represent a decimal point and is used to separate number sequences.


For instance, \textbf{2.5} is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.

Here is an example of version numbers ordering:

\textbf{Credits:}

Special thanks to @ts for adding this problem and creating all test cases.

\begin{verbatim}
0.1 < 1.1 < 1.2 < 13.37
\end{verbatim}

\textbf{Tags: }
\hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/compare-version-numbers/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int compareVersion(string version1, string version2) {
        int sub = vecsub(version2vec(version1), version2vec(version2));
        return min(1, max(-1, sub));
    }
private:
    vector<int> version2vec(const string& v) {
        vector<int> vec;
        size_t dot1 = -1, dot2;
        while ((dot2 = v.find('.', dot1 + 1)) != string::npos) {
            vec.push_back(atoi(v.substr(dot1 + 1, dot2 - dot1 - 1).c_str()));
            dot1 = dot2;
        }
        vec.push_back(atoi(v.substr(dot1 + 1).c_str()));
        return vec;
    }
    
    int vecsub(const vector<int>& v1, const vector<int>& v2) {
        for (size_t i = 0; i < v1.size() || i < v2.size(); ++i) {
            if (!(i < v1.size())) {
                if (v2[i] != 0) return -1;
            } else if (!(i < v2.size())) {
                if (v1[i] != 0) return 1;
            } else if (v1[i] != v2[i]) return v1[i] - v2[i];
        }
        return 0;
    }
}; 
\end{lstlisting}


\subsection{ Construct Binary Tree from Inorder and Postorder Traversal }
\label{ Construct Binary Tree from Inorder and Postorder Traversal }

\subsubsection*{Problem Description}
Given inorder and postorder traversal of a tree, construct the binary tree.

\textbf{Note:}


You may assume that duplicates do not exist in the tree.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Array ]{ Array },  \hyperref[ Depth-first Search ]{ Depth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {
        if (inorder.size() == 0) return NULL;
        int n = inorder.size();
        int post[n], in[n];
        for (int i = 0; i < n; ++i) {
            post[i] = postorder[i];
            in[i] = inorder[i];
        }
        return _bulidTree(post, in, n);
    }
private:
    TreeNode *_bulidTree(int post[], int in[], int n) {
        if (n == 0) return NULL;
        if (n == 1) {
            return new TreeNode(post[n - 1]);
        }
        int k = 0;
        while(k < n && in[k] != post[n - 1]) ++ k;
        TreeNode *root = new TreeNode(post[n - 1]);
        root->left = _bulidTree(post, in, k);
        root->right = _bulidTree(post + k, in + 1 + k, n - k - 1);
        return root;
    }
}; 
\end{lstlisting}


\subsection{ Construct Binary Tree from Preorder and Inorder Traversal }
\label{ Construct Binary Tree from Preorder and Inorder Traversal }

\subsubsection*{Problem Description}
Given preorder and inorder traversal of a tree, construct the binary tree.

\textbf{Note:}


You may assume that duplicates do not exist in the tree.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Array ]{ Array },  \hyperref[ Depth-first Search ]{ Depth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {
        if (preorder.size() == 0) return NULL;
        int n = preorder.size();
        int pre[n], in[n];
        for (int i = 0; i < n; ++i) {
            pre[i] = preorder[i];
            in[i] = inorder[i];
        }
        return _bulidTree(pre, in, n);
    }
private:
    TreeNode *_bulidTree(int pre[], int in[], int n) {
        if (n == 0) return NULL;
        if (n == 1) {
            return new TreeNode(pre[0]);
        }
        int k = 0;
        while(k < n && in[k] != pre[0]) ++ k;
        TreeNode *root = new TreeNode(pre[0]);
        root->left = _bulidTree(pre + 1, in, k);
        root->right = _bulidTree(pre + 1 + k, in + 1 + k, n - k - 1);
        return root;
    }
}; 
\end{lstlisting}


\subsection{ Container With Most Water }
\label{ Container With Most Water }

\subsubsection*{Problem Description}
Given \emph{n} non-negative integers \emph{a1}, \emph{a2}, ..., \emph{an}, where each represents a point at coordinate (\emph{i}, \emph{ai}). \emph{n} vertical lines are drawn such that the two endpoints of line \emph{i} is at (\emph{i}, \emph{ai}) and (\emph{i}, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

Note: You may not slant the container.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Two Pointers ]{ Two Pointers }


\rightline{\href{https://oj.leetcode.com/problems/container-with-most-water/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int maxArea(vector<int> &height) {
        int n = height.size();
        int s1[n], top1 = 0, s2[n], top2 = 0, area = 0;
        for(int i = 0; i < n; ++i) {
            if (top1 == 0 || height[s1[top1 - 1]] < height[i]) {
                s1[top1++] = i;
            }
        }
        for (int i = n - 1; i >= 0; --i) {
            if (top2 == 0 || height[s2[top2 - 1]] < height[i]) {
                s2[top2++] = i;
            }
        }
        int p1 = 0, p2 = 0;
        while(p1 < top1 && p2 < top2 && s1[p1] < s2[p2]) {
            int newarea = min(height[s1[p1]], height[s2[p2]]) * (s2[p2] - s1[p1]);
            area = max(area, newarea);
            if (height[s1[p1]] < height[s2[p2]]) {
                ++ p1;
            } else {
                ++ p2;
            }
        }
        return area;
    }
}; 
\end{lstlisting}


\subsection{ Convert Sorted Array to Binary Search Tree }
\label{ Convert Sorted Array to Binary Search Tree }

\subsubsection*{Problem Description}
Given an array where elements are sorted in ascending order, convert it to a height balanced BST.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Depth-first Search ]{ Depth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode *sortedArrayToBST(vector<int> &num) {
        int a[num.size()], n = num.size();
        for (int i = 0; i < n; ++i) {
            a[i] = num[i];
        }
        return _gen(a, n);
    }
private:
    TreeNode *_gen(int a[], int n) {
        if (n == 0) return NULL;
        TreeNode *root = new TreeNode(a[n / 2]);
        root->left = _gen(a, n / 2);
        root->right = _gen(a + n / 2 + 1, n - n / 2 - 1);
        return root;
    }
}; 
\end{lstlisting}


\subsection{ Convert Sorted List to Binary Search Tree }
\label{ Convert Sorted List to Binary Search Tree }

\subsubsection*{Problem Description}
Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.


\textbf{Tags: }
\hyperref[ Depth-first Search ]{ Depth-first Search },  \hyperref[ Linked List ]{ Linked List }


\rightline{\href{https://oj.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode *sortedListToBST(ListNode *head) {
        vector<int> vals;
        for (ListNode *p = head; p; p = p->next) {
            vals.push_back(p->val);
        }
        return _gen(vals, 0, vals.size());
    }
private:
    TreeNode *_gen(vector<int> &vals, int left, int right) {
        if (left >= right) {
            return NULL;
        }
        int mid = (left + right) >> 1;
        TreeNode *root = new TreeNode(vals[mid]);
        root->left = _gen(vals, left, mid);
        root->right = _gen(vals, mid + 1, right);
        return root;
    }
}; 
\end{lstlisting}


\subsection{ Copy List with Random Pointer }
\label{ Copy List with Random Pointer }

\subsubsection*{Problem Description}
A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.

Return a deep copy of the list.


\textbf{Tags: }
\hyperref[ Hash Table ]{ Hash Table },  \hyperref[ Linked List ]{ Linked List }


\rightline{\href{https://oj.leetcode.com/problems/copy-list-with-random-pointer/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode *next, *random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    RandomListNode *copyRandomList(RandomListNode *head) {
        map<RandomListNode*, RandomListNode*> keyword;
        keyword[NULL] = NULL;
        RandomListNode newhead(0), *tail;
        tail = &newhead;
        for (RandomListNode *p = head; p; p = p->next) {
            tail->next = new RandomListNode(p->label);
            tail = tail->next;
            keyword[p] = tail;
        }
        for (RandomListNode *p = head; p; p = p->next) {
            keyword[p]->random = keyword[p->random];
        }
        return newhead.next;
    }
}; 
\end{lstlisting}


\subsection{ Count and Say }
\label{ Count and Say }

\subsubsection*{Problem Description}
The count-and-say sequence is the sequence of integers beginning as follows:


\textbf{1, 11, 21, 1211, 111221, ...}

\textbf{1} is read off as \textbf{"one 1"} or \textbf{11}.


\textbf{11} is read off as \textbf{"two 1s"} or \textbf{21}.


\textbf{21} is read off as \textbf{"one 2}, then \textbf{one 1"} or \textbf{1211}.

Given an integer \emph{n}, generate the \emph{n}th sequence.

Note: The sequence of integers will be represented as a string.


\textbf{Tags: }
\hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/count-and-say/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    string countAndSay(int n) {
        string ans = "1";
        for (int k = 2; k <= n; ++k) {
            string read;
            ans.push_back('e');
            int cnt = 1;
            for (int i = 1; i < ans.size(); ++i) {
                if (ans[i - 1] == ans[i]) {
                    ++ cnt;
                } else {
                    char cs[32];
                    itoa(cnt, cs);
                    read += string(cs);
                    read.push_back(ans[i - 1]);
                    cnt = 1;
                }
            }
            ans = read;
        }
        return ans;
    }
private:
    int itoa(int n, char s[]) {
        if (n < 10) {
            s[0] = n + '0';
            s[1] = 0;
            return 1;
        }
        int len = itoa(n / 10, s);
        s[len++] = n % 10 + '0';
        s[len] = 0;
        return len;
    }
}; 
\end{lstlisting}


\subsection{ Decode Ways }
\label{ Decode Ways }

\subsubsection*{Problem Description}
A message containing letters from \textbf{A-Z} is being encoded to numbers using the following mapping:

Given an encoded message containing digits, determine the total number of ways to decode it.

For example,


Given encoded message \textbf{"12"},
it could be decoded as \textbf{"AB"} (1 2) or \textbf{"L"} (12).

The number of ways decoding \textbf{"12"} is 2.

\begin{verbatim}
'A' -> 1
'B' -> 2
...
'Z' -> 26
\end{verbatim}

\textbf{Tags: }
\hyperref[ Dynamic Programming ]{ Dynamic Programming },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/decode-ways/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int numDecodings(string s) {
        if (s.size() == 0) return 0;
        vector<int> f(s.size() + 1, 0);
        f[0] = 1;
        for (int i = 0; i < s.size(); ++i) {
            if ('1' <= s[i] && s[i] <= '9') {
                f[i + 1] += f[i];
            }
            if (i) {
                int p = (s[i - 1] - '0') * 10 + s[i] - '0';
                if (10 <= p && p <= 26) {
                    f[i + 1] += f[i - 1];
                }
            }
        }
        return f[s.size()];
    }
}; 
\end{lstlisting}


\subsection{ Distinct Subsequences }
\label{ Distinct Subsequences }

\subsubsection*{Problem Description}
Given a string \textbf{S} and a string \textbf{T}, count the number of distinct subsequences of \textbf{T} in \textbf{S}.

A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \textbf{"ACE"} is a subsequence of \textbf{"ABCDE"} while \textbf{"AEC"} is not).

Here is an example:


\textbf{S} = \textbf{"rabbbit"}, \textbf{T} = \textbf{"rabbit"}

Return \textbf{3}.


\textbf{Tags: }
\hyperref[ Dynamic Programming ]{ Dynamic Programming },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/distinct-subsequences/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int numDistinct(string S, string T) {
        vector<vector<int> > f(T.size() + 1, vector<int>(S.size() + 1, 0));
        for (int j = 0; j <= S.size(); ++j) {
            f[0][j] = 1;
        }
        for (int i = 1; i <= T.size(); ++i) {
            for (int j = 1; j <= S.size(); ++j) {
                f[i][j] = f[i][j - 1];
                if (T[i - 1] == S[j - 1]) {
                    f[i][j] += f[i - 1][j - 1];
                }
            }
        }
        return f[T.size()][S.size()];
    }
}; 
\end{lstlisting}


\subsection{ Divide Two Integers }
\label{ Divide Two Integers }

\subsubsection*{Problem Description}
Divide two integers without using multiplication, division and mod operator.

If it is overflow, return MAX\_INT.


\textbf{Tags: }
\hyperref[ Math ]{ Math },  \hyperref[ Binary Search ]{ Binary Search }


\rightline{\href{https://oj.leetcode.com/problems/divide-two-integers/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int divide(int dividend, int divisor) {
        long long remind, d1 = dividend, d2 = divisor;
        if (d2 == 0) return 0;
        if (d1 < 0 && d2 < 0) {
            return _divide(-d1, -d2, remind);
        }
        if (d1 < 0 && d2 > 0) {
            return -_divide(-d1, d2, remind);
        }
        if (d1 >= 0 && d2 < 0) {
            return -_divide(d1, -d2, remind);
        }
        if (d1 >= 0 && d2 > 0) {
            return _divide(d1, d2, remind);
        }
    }
private:
    long long _divide(long long dividend, long long divisor, long long &remind) {
        if (dividend < divisor) {
            remind = dividend;
            return 0;
        }
        long long ans = _divide(dividend >> 1, divisor, remind) << 1;
        remind = (remind << 1) | (dividend & 1);
        if (remind >= divisor) {
            remind -= divisor;
            ++ ans;
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Dungeon Game }
\label{ Dungeon Game }

\subsubsection*{Problem Description}
The demons had captured the princess (\textbf{P}) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (\textbf{K}) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.

The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.

Some of the rooms are guarded by demons, so the knight loses health (\emph{negative} integers) upon entering these rooms; 
other rooms are either empty (\emph{0's}) or contain magic orbs that increase the knight's health (\emph{positive} integers).

In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.

\textbf{Write a function to determine the knight's minimum initial health so that he is able to rescue the princess.}

For example, given the dungeon below, the initial health of the knight must be at least \textbf{7} if he follows the optimal path \textbf{RIGHT-$>$ RIGHT -$>$ DOWN -$>$ DOWN}.

\textbf{Notes:}
\begin{itemize}
\item The knight's health has no upper bound.
\item Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.  
\end{itemize}

\textbf{Credits:}

Special thanks to @stellari for adding this problem and creating all test cases.


\textbf{Tags: }
\hyperref[ Dynamic Programming ]{ Dynamic Programming },  \hyperref[ Binary Search ]{ Binary Search }


\rightline{\href{https://oj.leetcode.com/problems/dungeon-game/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int calculateMinimumHP(vector<vector<int> > &dungeon) {
        if (dungeon.size() == 0 || dungeon[0].size() == 0) return 0;
        int n = dungeon.size(), m = dungeon[0].size();
        for (int j = m - 2; j >= 0; --j) dungeon[n - 1][j] += min(0, dungeon[n - 1][j + 1]);
        for (int i = n - 2; i >= 0; --i) {
            dungeon[i][m - 1] += min(0, dungeon[i + 1][m - 1]);
            for (int j = m - 2; j >= 0; --j) {
                dungeon[i][j] += min(0, max(dungeon[i + 1][j], dungeon[i][j + 1]));
            }
        }
        return max(-dungeon[0][0], 0) + 1;
    }
}; 
\end{lstlisting}


\subsection{ Edit Distance }
\label{ Edit Distance }

\subsubsection*{Problem Description}
Given two words \emph{word1} and \emph{word2}, find the minimum number of steps required to convert \emph{word1} to \emph{word2}. (each operation is counted as 1 step.)

You have the following 3 operations permitted on a word:

a) Insert a character


b) Delete a character


c) Replace a character


\textbf{Tags: }
\hyperref[ Dynamic Programming ]{ Dynamic Programming },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/edit-distance/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size(), m = word2.size();
        if (n == 0 || m == 0) {
            return n + m;
        }
        int f[n + 1][m + 1];
        for (int i = 0; i <= n; ++i) {
            f[i][0] = i;
        }
        for (int j = 0; j <= m; ++j) {
            f[0][j] = j;
        }
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                if (word1[i - 1] == word2[j - 1]) {
                    f[i][j] = f[i - 1][j - 1];
                } else {
                    f[i][j] = min(f[i - 1][j - 1], min(f[i - 1][j], f[i][j - 1])) + 1;
                }
            }
        }
        return f[n][m];
    }
}; 
\end{lstlisting}


\subsection{ Evaluate Reverse Polish Notation }
\label{ Evaluate Reverse Polish Notation }

\subsubsection*{Problem Description}
Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are \textbf{+}, \textbf{-}, \textbf{*}, \textbf{/}. Each operand may be an integer or another expression.

Some examples:
\begin{verbatim}
  ["2", "1", "+", "3", "*"] -$>$ ((2 + 1) * 3) -$>$ 9
  ["4", "13", "5", "/", "+"] -$>$ (4 + (13 / 5)) -$>$ 6
\end{verbatim}


\textbf{Tags: }
\hyperref[ Stack ]{ Stack }


\rightline{\href{https://oj.leetcode.com/problems/evaluate-reverse-polish-notation/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int evalRPN(vector<string> &tokens) {
        stack<int> numbers;
        int a, b;
        for (int i = 0; i < tokens.size(); ++i) {
            if (tokens[i] == "+") {
                getab(numbers, a, b);
                numbers.push(a + b);
            } else if (tokens[i] == "-") {
                getab(numbers, a, b);
                numbers.push(a - b);
            } else  if (tokens[i] == "*") {
                getab(numbers, a, b);
                numbers.push(a * b);
            } else  if (tokens[i] == "/") {
                getab(numbers, a, b);
                numbers.push(a / b);
            } else {
                numbers.push(atoi(tokens[i].c_str()));
            }
        }
        return numbers.top();
    }
private:
    void getab(stack<int> &numbers, int &a, int &b) {
        b = numbers.top();
        numbers.pop();
        a = numbers.top();
        numbers.pop();
    }
}; 
\end{lstlisting}


\subsection{ Excel Sheet Column Number }
\label{ Excel Sheet Column Number }

\subsubsection*{Problem Description}
Related to question Excel Sheet Column Title

Given a column title as appear in an Excel sheet, return its corresponding column number.

For example:

\textbf{Credits:}

Special thanks to @ts for adding this problem and creating all test cases.

\begin{verbatim}
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
\end{verbatim}

\textbf{Tags: }
\hyperref[ Math ]{ Math }


\rightline{\href{https://oj.leetcode.com/problems/excel-sheet-column-number/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int titleToNumber(string s) {
        int result = 0;
        for (size_t i = 0; i < s.size(); ++i) {
            result = result * 26 + (s[i] - 'A') + 1;
        }
        return result;
    }
}; 
\end{lstlisting}


\subsection{ Excel Sheet Column Title }
\label{ Excel Sheet Column Title }

\subsubsection*{Problem Description}
Given a positive integer, return its corresponding column title as appear in an Excel sheet.

For example:

\textbf{Credits:}

Special thanks to @ifanchu for adding this problem and creating all test cases.

\begin{verbatim}
    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB 
\end{verbatim}

\textbf{Tags: }
\hyperref[ Math ]{ Math }


\rightline{\href{https://oj.leetcode.com/problems/excel-sheet-column-title/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    string convertToTitle(int n) {
        string result;
        for (; n; n = (n - 1) / 26) {
            result += char('A' + (n - 1) % 26);
        }
        reverse(result.begin(), result.end());
        return result;
    }
}; 
\end{lstlisting}


\subsection{ Factorial Trailing Zeroes }
\label{ Factorial Trailing Zeroes }

\subsubsection*{Problem Description}
Given an integer \emph{n}, return the number of trailing zeroes in \emph{n}!.

\textbf{Note: }Your solution should be in logarithmic time complexity.

\textbf{Credits:}

Special thanks to @ts for adding this problem and creating all test cases.


\textbf{Tags: }
\hyperref[ Math ]{ Math }


\rightline{\href{https://oj.leetcode.com/problems/factorial-trailing-zeroes/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int trailingZeroes(int n) {
        int result = 0;
        while (n) {
            n /= 5;
            result += n;
        }
        return result;
    }
}; 
\end{lstlisting}


\subsection{ Find Minimum in Rotated Sorted Array II }
\label{ Find Minimum in Rotated Sorted Array II }

\subsubsection*{Problem Description}
\emph{Follow up} for "Find Minimum in Rotated Sorted Array":


What if \emph{duplicates} are allowed?

Would this affect the run-time complexity? How and why?

Suppose a sorted array is rotated at some pivot unknown to you beforehand.

(i.e., \textbf{0 1 2 4 5 6 7} might become \textbf{4 5 6 7 0 1 2}).

Find the minimum element.

The array may contain duplicates.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Binary Search ]{ Binary Search }


\rightline{\href{https://oj.leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int findMin(const vector<int>& num) {
        return findMin(num, 0, int(num.size()) - 1);
    }
private:
    int findMin(const vector<int>& num, int left, int right) {
        if (left == right) return num[left];
        int mid = (left + right) / 2;
        if (num[left] > num[mid] || num[mid] < num[right]) return findMin(num, left, mid);
        if (num[mid] > num[right]) return findMin(num, mid + 1, right);
        return min(findMin(num, left, mid), findMin(num, mid + 1, right));
    }
};

\end{lstlisting}


\subsection{ Find Minimum in Rotated Sorted Array }
\label{ Find Minimum in Rotated Sorted Array }

\subsubsection*{Problem Description}
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

(i.e., \textbf{0 1 2 4 5 6 7} might become \textbf{4 5 6 7 0 1 2}).

Find the minimum element.

You may assume no duplicate exists in the array.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Binary Search ]{ Binary Search }


\rightline{\href{https://oj.leetcode.com/problems/find-minimum-in-rotated-sorted-array/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int findMin(const vector<int>& num) {
        int left = 0, right = int(num.size()) - 1;
        while (left <= right) {
            if (num[left] <= num[right]) return num[left];
            int mid = (left + right) / 2;
            if (num[left] <= num[mid]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
}; 
\end{lstlisting}


\subsection{ Find Peak Element }
\label{ Find Peak Element }

\subsubsection*{Problem Description}
A peak element is an element that is greater than its neighbors.

Given an input array where \textbf{num[i] ≠ num[i+1]}, find a peak element and return its index.

The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.

You may imagine that \textbf{num[-1] = num[n] = -∞}.

For example, in array \textbf{[1, 2, 3, 1]}, 3 is a peak element and your function should return the index number 2.

Your solution should be in logarithmic complexity.

\textbf{Credits:}

Special thanks to @ts for adding this problem and creating all test cases.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Binary Search ]{ Binary Search }


\rightline{\href{https://oj.leetcode.com/problems/find-peak-element/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int findPeakElement(const vector<int> &num) {
        int left = 0, right = num.size() - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if ((mid - 1 < left || num[mid - 1] < num[mid]) &&
                (mid + 1 > right || num[mid + 1] < num[mid])) {
                return mid;
            }
            if (mid - 1 >= left && num[mid - 1] > num[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}; 
\end{lstlisting}


\subsection{ First Missing Positive }
\label{ First Missing Positive }

\subsubsection*{Problem Description}
Given an unsorted integer array, find the first missing positive integer.

For example,


Given \textbf{[1,2,0]} return \textbf{3},


and \textbf{[3,4,-1,1]} return \textbf{2}.

Your algorithm should run in \emph{O}(\emph{n}) time and uses constant space.


\textbf{Tags: }
\hyperref[ Array ]{ Array }


\rightline{\href{https://oj.leetcode.com/problems/first-missing-positive/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int firstMissingPositive(int A[], int n) {
        if (n == 0) return 1;
        for (int i = 0, temp; i < n; ++i) {
            while(0 <= A[i] && A[i] < n && A[i] != i && A[i] != A[A[i]]) {
                swap(A[i], A[A[i]]);
            }
        }
        for (int i = 1; i < n; ++i) {
            if (A[i] != i) {
                return i;
            }
        }
        return n + (A[0] == n);
    }
private:
    void swap(int &a, int &b) {
        a ^= b ^= a ^= b;
    }
}; 
\end{lstlisting}


\subsection{ Flatten Binary Tree to Linked List }
\label{ Flatten Binary Tree to Linked List }

\subsubsection*{Problem Description}
Given a binary tree, flatten it to a linked list in-place.

For example,


Given
\begin{verbatim}
         1
        / \
       2   5
      / \   \
     3   4   6
\end{verbatim}

If you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal.

\begin{verbatim}
   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6
\end{verbatim}

\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Depth-first Search ]{ Depth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    void flatten(TreeNode *root) {
        TreeNode *begin, *end;
        _flatten(root, begin, end);
    }
private:
    void _flatten(TreeNode *root, TreeNode * &begin, TreeNode * &end) {
        if (root == NULL) {
            begin = end = NULL;
            return;
        }
        TreeNode *lbegin, *lend, *rbegin, *rend;
        _flatten(root->left, lbegin, lend);
        _flatten(root->right, rbegin, rend);
        root->left = NULL;
        begin = end = root;
        if (lbegin) {
            end->right = lbegin;
            end = lend;
        }
        if (rbegin) {
            end->right = rbegin;
            end = rend;
        }
    }
};

\end{lstlisting}


\subsection{ Fraction to Recurring Decimal }
\label{ Fraction to Recurring Decimal }

\subsubsection*{Problem Description}
Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.

If the fractional part is repeating, enclose the repeating part in parentheses.

For example,
\begin{itemize}
\item Given numerator = 1, denominator = 2, return "0.5".
\item Given numerator = 2, denominator = 1, return "2".
\item Given numerator = 2, denominator = 3, return "0.(6)".
\end{itemize}

\textbf{Credits:}

Special thanks to @Shangrila for adding this problem and creating all test cases.


\textbf{Tags: }
\hyperref[ Hash Table ]{ Hash Table },  \hyperref[ Math ]{ Math }


\rightline{\href{https://oj.leetcode.com/problems/fraction-to-recurring-decimal/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    string fractionToDecimal(int numerator, int denominator) {
        if (numerator < 0 && denominator < 0) {
            return fractionToDecimalU(-numerator, -denominator);
        }
        if (numerator < 0 && denominator > 0) {
            return "-" + fractionToDecimalU(-numerator, denominator);
        }
        if (numerator > 0 && denominator < 0) {
            return "-" + fractionToDecimalU(numerator, -denominator);
        }
        return fractionToDecimalU(numerator, denominator);
    }
    
private:
    string fractionToDecimalU(unsigned numerator, unsigned denominator) {
        unsigned integer = numerator / denominator;
        numerator %= denominator;
        std::string result = std::to_string(integer);
        if (numerator == 0) return result;
        std::vector<unsigned> bits;
        std::map<unsigned, size_t> remainder;
        while (numerator && remainder.find(numerator) == remainder.end()) {
            remainder[numerator] = bits.size();
            bits.push_back(unsigned((unsigned long long)numerator * 10 / denominator));
            numerator = unsigned((unsigned long long)numerator * 10 % denominator);
        }
        result += '.';
        for (size_t i = 0; i < bits.size(); ++i) {
            if (numerator && i == remainder[numerator]) {
                result += '(';
            }
            result += char('0' + bits[i]);
        }
        if (numerator) result += ')';
        return result;
    }
}; 
\end{lstlisting}


\subsection{ Gas Station }
\label{ Gas Station }

\subsubsection*{Problem Description}
There are \emph{N} gas stations along a circular route, where the amount of gas at station \emph{i} is \textbf{gas[i]}.

You have a car with an unlimited gas tank and it costs \textbf{cost[i]} of gas to travel from station \emph{i} to its next station (\emph{i}+1). You begin the journey with an empty tank at one of the gas stations.

Return the starting gas station's index if you can travel around the circuit once, otherwise return -1.

\textbf{Note:}
The solution is guaranteed to be unique.


\textbf{Tags: }
\hyperref[ Greedy ]{ Greedy }


\rightline{\href{https://oj.leetcode.com/problems/gas-station/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {
        int n = gas.size(), left = 0, right = 0;
        vector<int> leftgas(n * 2), que(n * 2);
        leftgas[0] = 0;
        for (int i = 1; i < leftgas.size(); ++i) {
            leftgas[i] = leftgas[i - 1] + gas[(i - 1) % n] - cost[(i - 1) % n];
        }
        for (int i = 0; i < n; ++i) {
            while (left < right && leftgas[que[right - 1]] >= leftgas[i]) {
                -- right;
            }
            que[right++] = i;
        }
        for (int i = n; i < leftgas.size(); ++i) {
            if (que[left] == i - n) ++left;
            while (left < right && leftgas[que[right - 1]] >= leftgas[i]) {
                -- right;
            }
            que[right++] = i;
            if (leftgas[que[left]] >= leftgas[i - n]) {
                return i - n;
            }
        }
        return -1;
    }
};s 
\end{lstlisting}


\subsection{ Generate Parentheses }
\label{ Generate Parentheses }

\subsubsection*{Problem Description}
Given \emph{n} pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given \emph{n} = 3, a solution set is:

\textbf{"((()))", "(()())", "(())()", "()(())", "()()()"}


\textbf{Tags: }
\hyperref[ Backtracking ]{ Backtracking },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/generate-parentheses/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> ans;
        if (n <= 0) return ans;
        vector<vector<string> > ansSet(n + 1);
        ansSet[0].push_back("");
        for (int k = 1; k <= n; ++k) {
            for (int i = 0; i < ansSet[k - 1].size(); ++i) {
                ansSet[k].push_back("(" + ansSet[k - 1][i] + ")");
            }
            for (int i = 1; i < k; ++i) {
                for (int p = 0; p < ansSet[i - 1].size(); ++p) {
                    for (int q = 0; q < ansSet[k - i].size(); ++q) {
                        ansSet[k].push_back("(" + ansSet[i - 1][p] + ")" + ansSet[k - i][q]);
                    }
                }
            }
        }
        return ansSet[n];
    }
}; 
\end{lstlisting}


\subsection{ Gray Code }
\label{ Gray Code }

\subsubsection*{Problem Description}
The gray code is a binary numeral system where two successive values differ in only one bit.

Given a non-negative integer \emph{n} representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

For example, given \emph{n} = 2, return \textbf{[0,1,3,2]}. Its gray code sequence is:

\textbf{Note:}


For a given \emph{n}, a gray code sequence is not uniquely defined.

For example, \textbf{[0,2,3,1]} is also a valid gray code sequence according to the above definition.

For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.

\begin{verbatim}
00 - 0
01 - 1
11 - 3
10 - 2
\end{verbatim}

\textbf{Tags: }
\hyperref[ Backtracking ]{ Backtracking }


\rightline{\href{https://oj.leetcode.com/problems/gray-code/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> ans;
        ans.push_back(0);
        if (n <= 0) return ans;
        ans.push_back(1);
        for (int k = 2; k <= n; ++k) {
            vector<int> extended;
            for (int i = 0; i < ans.size(); ++i) {
                if (i % 2 == 0) {
                    extended.push_back(ans[i] << 1);
                    extended.push_back(ans[i] << 1 | 1);
                } else {
                    extended.push_back(ans[i] << 1 | 1);
                    extended.push_back(ans[i] << 1);
                }
            }
            ans = extended;
        } 
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Implement strStr() }
\label{ Implement strStr() }

\subsubsection*{Problem Description}

\textbf{Tags: }


\rightline{\href{https://oj.leetcode.com/problems/implement-strstr()/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    char *strStr(char *s, char *t) {
        int n = strlen(t);
        if (n == 0) return s;
        int next[n], pos = 0;
        next[0] = pos;
        for (int i = 1; i < n; ++i) {
            while(pos && t[next[pos]] != t[i]) {
                pos = next[pos - 1];
            }
            next[i] = pos = pos + (t[pos] == t[i]);
        }
        pos = 0;
        for (int i = 0; s[i]; ++i) {
            while (pos && t[pos] != s[i]) {
                pos = next[pos - 1];
            }
            pos += t[pos] == s[i];
            if (pos == n) return s + i - n + 1;
        }
        return NULL;
    }
};

\end{lstlisting}


\subsection{ Insert Interval }
\label{ Insert Interval }

\subsubsection*{Problem Description}
Given a set of \emph{non-overlapping} intervals, insert a new interval into the intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.

\textbf{Example 1:}


Given intervals \textbf{[1,3],[6,9]}, insert and merge \textbf{[2,5]} in as \textbf{[1,5],[6,9]}.

\textbf{Example 2:}


Given \textbf{[1,2],[3,5],[6,7],[8,10],[12,16]}, insert and merge \textbf{[4,9]} in as \textbf{[1,2],[3,10],[12,16]}.

This is because the new interval \textbf{[4,9]} overlaps with \textbf{[3,5],[6,7],[8,10]}.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Sort ]{ Sort }


\rightline{\href{https://oj.leetcode.com/problems/insert-interval/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {
        vector<Interval> ans;
        bool newin = false;
        for (int i = 0; i < intervals.size(); ++i) {
            if (intervals[i].end < newInterval.start) {
                ans.push_back(intervals[i]);
            } else if (intervals[i].start > newInterval.end) {
                if (!newin) {
                    ans.push_back(newInterval);
                    newin = true;
                }
                ans.push_back(intervals[i]);
            } else {
                newInterval.start = min(newInterval.start, intervals[i].start);
                newInterval.end = max(newInterval.end, intervals[i].end);
            }
        }
        if (!newin) ans.push_back(newInterval);
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Insertion Sort List }
\label{ Insertion Sort List }

\subsubsection*{Problem Description}
Sort a linked list using insertion sort.


\textbf{Tags: }
\hyperref[ Linked List ]{ Linked List },  \hyperref[ Sort ]{ Sort }


\rightline{\href{https://oj.leetcode.com/problems/insertion-sort-list/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *insertionSortList(ListNode *head) {
        ListNode *newhead = NULL, *p = head, *q;
        while (p) {
            q = p;
            p = p->next;
            insert(newhead, q);
        }
        return newhead;
    }
    
private:
    void insert(ListNode* &head, ListNode *node) {
        node->next = NULL;
        if (head == NULL) {
            head = node;
        } else if (node->val < head->val) {
            node->next = head;
            head = node;
        } else {
            for (ListNode *p = head; p; p = p->next) {
                if (p->next == NULL || p->next->val >= node->val) {
                    node->next = p->next;
                    p->next = node;
                    return ;
                }
            }
        }
    }
}; 
\end{lstlisting}


\subsection{ Integer to Roman }
\label{ Integer to Roman }

\subsubsection*{Problem Description}
Given an integer, convert it to a roman numeral.

Input is guaranteed to be within the range from 1 to 3999.


\textbf{Tags: }
\hyperref[ Math ]{ Math },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/integer-to-roman/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    string intToRoman(int num) {
        char r1 = 'I', r5 = 'V', r10 = 'X', r50 = 'L', r100 = 'C', r500 = 'D', r1000 = 'M';
        string roman;
        roman += digital2roman(num / 1000, r1000, ' ', ' ');
        roman += digital2roman(num % 1000 / 100, r100, r500, r1000);
        roman += digital2roman(num % 100 / 10, r10, r50, r100);
        roman += digital2roman(num % 10, r1, r5, r10);
        return roman;
    }
    
private:
    string digital2roman(int x, char c1, char c5, char c10) {
        string roman;
        if (1 <= x && x <= 3) {
            switch (x) {
                case 3:
                    roman.push_back(c1);
                case 2:
                    roman.push_back(c1);
                case 1:
                    roman.push_back(c1);
            }
        } else if (x == 4) {
            roman.push_back(c1);
            roman.push_back(c5);
        } else if (5 <= x && x <= 8) {
            roman.push_back(c5);
            switch (x) {
                case 8:
                    roman.push_back(c1);
                case 7:
                    roman.push_back(c1);
                case 6 :
                    roman.push_back(c1);
            }
        } else if (x == 9) {
            roman.push_back(c1);
            roman.push_back(c10);
        }
        return roman;
    }
}; 
\end{lstlisting}


\subsection{ Interleaving String }
\label{ Interleaving String }

\subsubsection*{Problem Description}
Given \emph{s1}, \emph{s2}, \emph{s3}, find whether \emph{s3} is formed by the interleaving of \emph{s1} and \emph{s2}.

For example,


Given:


\emph{s1} = \textbf{"aabcc"},


\emph{s2} = \textbf{"dbbca"},

When \emph{s3} = \textbf{"aadbbcbcac"}, return true.


When \emph{s3} = \textbf{"aadbbbaccc"}, return false.


\textbf{Tags: }
\hyperref[ Dynamic Programming ]{ Dynamic Programming },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/interleaving-string/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        if (s1.size() + s2.size() != s3.size()) return false;
        vector<vector<bool> > f(s1.size() + 1, vector<bool>(s2.size() + 1, false));
        f[0][0] = true;
        for (int i = 0; i <= s1.size(); ++i) {
            for (int j = 0; j <= s2.size(); ++j) {
                if (f[i][j]) {
                    if (i != s1.size() && s1[i] == s3[i + j]) {
                        f[i + 1][j] = true;
                    }
                    if (j != s2.size() && s2[j] == s3[i + j]) {
                        f[i][j + 1] = true;
                    }
                }
            }
        }
        return f[s1.size()][s2.size()];
    }
}; 
\end{lstlisting}


\subsection{ Intersection of Two Linked Lists }
\label{ Intersection of Two Linked Lists }

\subsubsection*{Problem Description}
Write a program to find the node at which the intersection of two singly linked lists begins.

For example, the following two linked lists:

begin to intersect at node c1.

\textbf{Notes:}
\begin{itemize}
\item If the two linked lists have no intersection at all, return \textbf{null}.
\item The linked lists must retain their original structure after the function returns. 
\item You may assume there are no cycles anywhere in the entire linked structure.
\item Your code should preferably run in O(n) time and use only O(1) memory.
\end{itemize}

\textbf{Credits:}

Special thanks to @stellari for adding this problem and creating all test cases.

\begin{verbatim}
A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
\end{verbatim}

\textbf{Tags: }
\hyperref[ Linked List ]{ Linked List }


\rightline{\href{https://oj.leetcode.com/problems/intersection-of-two-linked-lists/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        size_t lena = ListSize(headA);
        size_t lenb = ListSize(headB);
        while (lena && lenb) {
            if (headA == headB) return headA;
            if (lena >= lenb) {
                -- lena;
                headA = headA->next;
            } else {
                -- lenb;
                headB = headB->next;
            }
        }
        return nullptr;
    }
private:
    size_t ListSize(ListNode *head) {
        size_t size = 0;
        while (head) {
            ++ size;
            head = head->next;
        }
        return size;
    }
}; 
\end{lstlisting}


\subsection{ Jump Game II }
\label{ Jump Game II }

\subsubsection*{Problem Description}
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

For example:


Given array A = \textbf{[2,3,1,1,4]}

The minimum number of jumps to reach the last index is \textbf{2}. (Jump \textbf{1} step from index 0 to 1, then \textbf{3} steps to the last index.)


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Greedy ]{ Greedy }


\rightline{\href{https://oj.leetcode.com/problems/jump-game-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int jump(int A[], int n) {
        priority_queue<Point> que;
        Point last;
        que.push(Point());
        for (int i = 0; i < n; ++i) {
            last = que.top();
            while (last.x < i) {
                que.pop();
                last = que.top();
            }
            if (i == n - 1) return last.value;
            que.push(Point(i + A[i], last.value + 1));
        }
    }
private:
    struct Point {
        int x, value;
        Point(): x(0), value(0){};
        Point(int x, int value):x(x), value(value){};
        bool operator<(const Point &p) const {
            return value > p.value;
        }
    };
}; 
\end{lstlisting}


\subsection{ Jump Game }
\label{ Jump Game }

\subsubsection*{Problem Description}
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

For example:


A = \textbf{[2,3,1,1,4]}, return \textbf{true}.

A = \textbf{[3,2,1,0,4]}, return \textbf{false}.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Greedy ]{ Greedy }


\rightline{\href{https://oj.leetcode.com/problems/jump-game/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    bool canJump(int A[], int n) {
        if (n <= 1) return true;
        int maxJump = A[0];
        for (int i = 0; i < n; ++i) {
            if (maxJump < i) return false;
            maxJump = max(maxJump, A[i] + i);
        }
        return true;
    }
}; 
\end{lstlisting}


\subsection{ Largest Number }
\label{ Largest Number }

\subsubsection*{Problem Description}
Given a list of non negative integers, arrange them such that they form the largest number.

For example, given \textbf{[3, 30, 34, 5, 9]}, the largest formed number is \textbf{9534330}.

Note: The result may be very large, so you need to return a string instead of an integer.

\textbf{Credits:}

Special thanks to @ts for adding this problem and creating all test cases.


\textbf{Tags: }
\hyperref[ Sort ]{ Sort }


\rightline{\href{https://oj.leetcode.com/problems/largest-number/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    static bool cmp(const string& a, const string& b) {
        return a + b > b + a;
    }
    
    string largestNumber(vector<int> &num) {
        vector<string> numstr(num.size());
        for (size_t i = 0; i < num.size(); ++i) {
            numstr[i] = std::to_string(num[i]);
        }
        std::sort(numstr.begin(), numstr.end(), cmp);
        string result;
        size_t i = 0;
        while (i < numstr.size() && numstr[i] == "0") ++i;
        for (; i < numstr.size(); ++i) {
            result += numstr[i];
        }
        return result == ""? "0": result;
    }
};

\end{lstlisting}


\subsection{ Largest Rectangle in Histogram }
\label{ Largest Rectangle in Histogram }

\subsubsection*{Problem Description}
Given \emph{n} non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.

Above is a histogram where width of each bar is 1, given height = \textbf{[2,1,5,6,2,3]}.

The largest rectangle is shown in the shaded area, which has area = \textbf{10} unit.

For example,


Given height = \textbf{[2,1,5,6,2,3]},


return \textbf{10}.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Stack ]{ Stack }


\rightline{\href{https://oj.leetcode.com/problems/largest-rectangle-in-histogram/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int largestRectangleArea(vector<int> &height) {
        int area = 0, n = height.size();
        int h[n + 2];
        for (int i = 1; i <= n; ++i) {
            h[i] = height[i - 1];
        }
        h[0] = h[n + 1] = -1;
        
        vector<int> less(n + 2);
        stack<int> min1, min2;
        min2.push(n + 1);
        for (int i = n; i; --i) {
            while(h[min2.top()] >= h[i]) {
                min2.pop();
            }
            less[i] = min2.top();
            min2.push(i);
        }
        min1.push(0);
        for (int i = 1; i <= n; ++i) {
            while(h[min1.top()] >= h[i]) {
                min1.pop();
            }
            area = max(area, h[i] * (less[i] - min1.top() - 1));
            min1.push(i);
        }
        return area;
    }
}; 
\end{lstlisting}


\subsection{ Length of Last Word }
\label{ Length of Last Word }

\subsubsection*{Problem Description}
Given a string \emph{s} consists of upper/lower-case alphabets and empty space characters \textbf{' '}, return the length of last word in the string.

If the last word does not exist, return 0.

\textbf{Note:} A word is defined as a character sequence consists of non-space characters only.

For example, 


Given \emph{s} = \textbf{"Hello World"},


return \textbf{5}.


\textbf{Tags: }
\hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/length-of-last-word/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int lengthOfLastWord(const char *s) {
        int lastlen = 0;
        for(int i = 0; s[i]; ++i) {
            if (s[i] != ' ') {
                int p = i + 1;
                while (s[p] && s[p] != ' ') {
                    ++ p;
                }
                lastlen = p - i;
                i = p - 1;
            }
        }
        return lastlen;
    }
};


\end{lstlisting}


\subsection{ Letter Combinations of a Phone Number }
\label{ Letter Combinations of a Phone Number }

\subsubsection*{Problem Description}
Given a digit string, return all possible letter combinations that the number could represent.

A mapping of digit to letters (just like on the telephone buttons) is given below.



\textbf{Note:}


Although the above answer is in lexicographical order, your answer could be in any order you want.

\begin{verbatim}
<b>Input:</b>Digit string "23"
<b>Output:</b> ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
\end{verbatim}

\textbf{Tags: }
\hyperref[ Backtracking ]{ Backtracking },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/letter-combinations-of-a-phone-number/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        string keys[] = {" ", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        vector<string> ans;
        string let = "";
        _gen(digits, 0, ans, let, keys);
        return ans;
    }
private:
    void _gen(string &digits, int k, vector<string> &ans, string &let, string keys[]) {
        if (k >= digits.size()) {
            ans.push_back(let);
            return;
        }
        for (int i = 0; i < keys[digits[k] - '0'].size(); ++i) {
            let.push_back(keys[digits[k] - '0'][i]);
            _gen(digits, k + 1, ans, let, keys);
            let.pop_back();
        }
    }
}; 
\end{lstlisting}


\subsection{ Linked List Cycle II }
\label{ Linked List Cycle II }

\subsubsection*{Problem Description}
Given a linked list, return the node where the cycle begins. If there is no cycle, return \textbf{null}.

Follow up:
Can you solve it without using extra space?


\textbf{Tags: }
\hyperref[ Linked List ]{ Linked List },  \hyperref[ Two Pointers ]{ Two Pointers }


\rightline{\href{https://oj.leetcode.com/problems/linked-list-cycle-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        set<ListNode*> pset;
        for (ListNode *p = head; p; p = p->next) {
            if (pset.find(p) != pset.end()) {
                return p;
            }
            pset.insert(p);
        }
        return NULL;
    }
}; 
\end{lstlisting}


\subsection{ Linked List Cycle }
\label{ Linked List Cycle }

\subsubsection*{Problem Description}
Given a linked list, determine if it has a cycle in it.

Follow up:


Can you solve it without using extra space?


\textbf{Tags: }
\hyperref[ Linked List ]{ Linked List },  \hyperref[ Two Pointers ]{ Two Pointers }


\rightline{\href{https://oj.leetcode.com/problems/linked-list-cycle/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        set<ListNode*> pset;
        for (ListNode *p = head; p; p = p->next) {
            if (pset.find(p) != pset.end()) {
                return true;
            }
            pset.insert(p);
        }
        return false;
    }
}; 
\end{lstlisting}


\subsection{ Longest Common Prefix }
\label{ Longest Common Prefix }

\subsubsection*{Problem Description}
Write a function to find the longest common prefix string amongst an array of strings.


\textbf{Tags: }
\hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/longest-common-prefix/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    string longestCommonPrefix(vector<string> &strs) {
        if (strs.size() == 0) return "";
        string ans;
        for (int k = 0; k < strs[0].size(); ++k) {
            bool diff = false;
            for (int i = 1; i < strs.size(); ++i) {
                if (strs[i].size() <= k || strs[i][k] != strs[0][k]) {
                    diff = true;
                    break;
                }
            }
            if (diff) break;
            ans.push_back(strs[0][k]);
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Longest Consecutive Sequence }
\label{ Longest Consecutive Sequence }

\subsubsection*{Problem Description}
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

For example,


Given \textbf{[100, 4, 200, 1, 3, 2]},


The longest consecutive elements sequence is \textbf{[1, 2, 3, 4]}. Return its length: \textbf{4}.

Your algorithm should run in O(\emph{n}) complexity.


\textbf{Tags: }
\hyperref[ Array ]{ Array }


\rightline{\href{https://oj.leetcode.com/problems/longest-consecutive-sequence/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int longestConsecutive(vector<int> &num) {
        if (num.size() == 0) return 0;
        sort(num.begin(), num.end());
        num.resize(unique(num.begin(), num.end()) - num.begin());
        int res = 1, cnt = 1;
        for (int i = 1; i < num.size(); ++i) {
            if (num[i] == num[i - 1] + 1) {
                ++ cnt;
            } else {
                cnt = 1;
            }
            res = max(res, cnt);
        }
        return res;        
    }
};

\end{lstlisting}


\subsection{ Longest Palindromic Substring }
\label{ Longest Palindromic Substring }

\subsubsection*{Problem Description}
Given a string \emph{S}, find the longest palindromic substring in \emph{S}. You may assume that the maximum length of \emph{S} is 1000, and there exists one unique longest palindromic substring.


\textbf{Tags: }
\hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/longest-palindromic-substring/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
bool f[1010][1010];

class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if (n == 0) return "";
        int lx = 0, ly = 1;
        for (int len = 0; len <= n; ++len) {
            for (int i = 0; i + len <= n; ++i) {
                int j = i + len;
                if (len == 0 || len == 1) {
                    f[i][j] = true;
                } else {
                    f[i][j] = (f[i + 1][j - 1] && s[i] == s[j - 1]);
                    if (f[i][j] && ly - lx < len) {
                        lx = i, ly = j;
                    }
                }
            }
        }
        return s.substr(lx, ly - lx);
    }
};

\end{lstlisting}


\subsection{ Longest Substring Without Repeating Characters }
\label{ Longest Substring Without Repeating Characters }

\subsubsection*{Problem Description}
Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for "abcabcbb" is "abc", which the length is 3. For "bbbbb" the longest substring is "b", with the length of 1.


\textbf{Tags: }
\hyperref[ Hash Table ]{ Hash Table },  \hyperref[ Two Pointers ]{ Two Pointers },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/longest-substring-without-repeating-characters/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector<int> cnt(256, 0);
        int ans = 0;
        for (int i = 0, begin = 0; i < s.size(); ++i) {
            ++ cnt[s[i]];
            while (cnt[s[i]] >= 2) {
                -- cnt[s[begin++]];
            }
            ans = max(ans, i - begin + 1);
        }
        return ans;
    }
};

\end{lstlisting}


\subsection{ Longest Valid Parentheses }
\label{ Longest Valid Parentheses }

\subsubsection*{Problem Description}
Given a string containing just the characters \textbf{'('} and \textbf{')'}, find the length of the longest valid (well-formed) parentheses substring.

For \textbf{"(()"}, the longest valid parentheses substring is \textbf{"()"}, which has length = 2.

Another example is \textbf{")()())"}, where the longest valid parentheses substring is \textbf{"()()"}, which has length = 4.


\textbf{Tags: }
\hyperref[ Dynamic Programming ]{ Dynamic Programming },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/longest-valid-parentheses/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> stk;
        stk.push(-1);
        int ans = 0;
        for (int i = 0; i < s.size(); ++i) {
            if (stk.size() >= 2 && s[stk.top()] == '(' && s[i] == ')') {
                stk.pop();
                ans = max(ans, i - stk.top());
            } else {
                stk.push(i);
            }
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ LRU Cache }
\label{ LRU Cache }

\subsubsection*{Problem Description}
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: \textbf{get} and \textbf{set}.

\textbf{get(key)} - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
\textbf{set(key, value)} - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.


\textbf{Tags: }
\hyperref[ Data Structure ]{ Data Structure }


\rightline{\href{https://oj.leetcode.com/problems/lru-cache/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
struct LinkedListNode {
    LinkedListNode(): pre(nullptr), next(nullptr) { }
    int key, value;
    LinkedListNode *pre, *next;
};

class LRUCache{
public:
    LRUCache(int capacity): capacity(capacity) {
        head.next = &tail;
        tail.pre = &head;
    }

    ~LRUCache() {
    	for (LinkedListNode *node = head.next; node != &tail; node = head.next) {
    		head.next = node->next;
    		delete node;
    	}
    }

    int get(int key) {
        if (hashtable.find(key) != hashtable.end()) {
            LinkedListNode* node = hashtable[key];
            erase(node), push(node);
            return node->value;
        }
        return -1;
    }
    
    void set(int key, int value) {
        LinkedListNode* node;
        if (hashtable.find(key) != hashtable.end()) {
            node = hashtable[key];
            node->key = key, node->value = value;
            erase(node), push(node);
            return ;
        }
        if (hashtable.size() == capacity) {
            node = tail.pre;
            erase(node);
            hashtable.erase(node->key);
        } else {
            node = new LinkedListNode();
        }
        node->key = key, node->value = value;
        hashtable[key] = node;
        push(node);
    }
    
private:
    
    void push(LinkedListNode* node) {
        node->pre = &head;
        node->next = head.next;
        head.next->pre = node;
        head.next = node;
    }
    
    void erase(LinkedListNode* node) {
        node->pre->next = node->next;
        node->next->pre = node->pre;
    }
    
    LinkedListNode head, tail;
    unordered_map<int, LinkedListNode*> hashtable;
    int capacity;
};

\end{lstlisting}


\subsection{ Majority Element }
\label{ Majority Element }

\subsubsection*{Problem Description}
Given an array of size \emph{n}, find the majority element. The majority element is the element that appears more than \textbf{⌊ n/2 ⌋} times.

You may assume that the array is non-empty and the majority element always exist in the array.

\textbf{Credits:}

Special thanks to @ts for adding this problem and creating all test cases.


\textbf{Tags: }
\hyperref[ Divide and Conquer ]{ Divide and Conquer },  \hyperref[ Array ]{ Array },  \hyperref[ Bit Manipulation ]{ Bit Manipulation }


\rightline{\href{https://oj.leetcode.com/problems/majority-element/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int majorityElement(vector<int> &num) {
        std::stack<int> stk;
        for (size_t i = 0; i < num.size(); ++i) {
            if (!stk.empty() && stk.top() != num[i]) {
                stk.pop();
            } else {
                stk.push(num[i]);
            }
        }
        return stk.top();
    }
}; 
\end{lstlisting}


\subsection{ Max Points on a Line }
\label{ Max Points on a Line }

\subsubsection*{Problem Description}
Given \emph{n} points on a 2D plane, find the maximum number of points that lie on the same straight line.


\textbf{Tags: }
\hyperref[ Hash Table ]{ Hash Table },  \hyperref[ Math ]{ Math }


\rightline{\href{https://oj.leetcode.com/problems/max-points-on-a-line/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for a point.
 * struct Point {
 *     int x;
 *     int y;
 *     Point() : x(0), y(0) {}
 *     Point(int a, int b) : x(a), y(b) {}
 * };
 */
class Solution {
public:
    int maxPoints(vector<Point> &points) {
        int ans = min(2, (int)points.size());
        for (int i = 0; i < points.size(); ++i) {
            for (int j = i + 1; j < points.size(); ++j) {
                ans = max(ans, pointsInLine(points, points[i], points[j]));
            }
        }
        return ans;
    }
    
private:
    int pointsInLine(const vector<Point> &points, const Point &p1, const Point &p2) {
        int count = 0;
        for (int i = 0; i < points.size(); ++i) {
            if (!equal(p1, p2) && inLine(p1, p2, points[i]) || equal(p1, p2) && equal(points[i], p1)) {
                ++ count;
            }
        }
        return count;
    }
    
    bool equal(const Point &p1, const Point &p2) {
        return p1.x == p2.x && p1.y == p2.y;
    }
    
    bool inLine(const Point &p1, const Point &p2, const Point &p3) {
        return (p2.y - p1.y) * (p3.x - p1.x) == (p2.x - p1.x) * (p3.y - p1.y);
    }
}; 
\end{lstlisting}


\subsection{ Maximal Rectangle }
\label{ Maximal Rectangle }

\subsubsection*{Problem Description}
Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing all ones and return its area.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Hash Table ]{ Hash Table },  \hyperref[ Stack ]{ Stack },  \hyperref[ Dynamic Programming ]{ Dynamic Programming }


\rightline{\href{https://oj.leetcode.com/problems/maximal-rectangle/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int maximalRectangle(vector<vector<char> > &matrix) {
        if (matrix.size() == 0) return 0;
        int n = matrix.size(), m = matrix[0].size();
        vector<vector<int> > len(n, vector<int> (m + 2));
        for (int j = 0; j < m; ++j) {
            for (int i = n - 1; i >= 0; --i) {
                len[i][j + 1] = (matrix[i][j] == '0'? 0: (i == n - 1? 1: len[i + 1][j + 1] + 1));
            }
        }
        int area = 0;
        for (int k = 0; k < n; ++k) {
            len[k][0] = len[k][m + 1] = -1;
            vector<int> &height = len[k], less(m + 2);
            stack<int> min1, min2;
            min2.push(m + 1);
            for (int i = m; i; --i) {
                while(height[min2.top()] >= height[i]) {
                    min2.pop();
                }
                less[i] = min2.top();
                min2.push(i);
            }
            min1.push(0);
            for (int i = 1; i <= m; ++i) {
                while(height[min1.top()] >= height[i]) {
                    min1.pop();
                }
                area = max(area, height[i] * (less[i] - min1.top() - 1));
                min1.push(i);
            }
        }
        return area;
    }
}; 
\end{lstlisting}


\subsection{ Maximum Depth of Binary Tree }
\label{ Maximum Depth of Binary Tree }

\subsubsection*{Problem Description}
Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Depth-first Search ]{ Depth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/maximum-depth-of-binary-tree/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode *root) {
        if (root == NULL) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
}; 
\end{lstlisting}


\subsection{ Maximum Gap }
\label{ Maximum Gap }

\subsubsection*{Problem Description}
Given an unsorted array, find the maximum difference between the successive elements in its sorted form.

Try to solve it in linear time/space.

Return 0 if the array contains less than 2 elements.

You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.

\textbf{Credits:}

Special thanks to @porker2008 for adding this problem and creating all test cases.


\textbf{Tags: }
\hyperref[ Sort ]{ Sort }


\rightline{\href{https://oj.leetcode.com/problems/maximum-gap/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int maximumGap(vector<int> &num) {
        int n = int(num.size());
        if (n <= 1) return 0;
        int maxvalue = *(max_element(num.begin(), num.end()));
        int minvalue = *(min_element(num.begin(), num.end()));
        vector<pair<int, int>> interval(n, make_pair(maxvalue, -1));
        int valsize = (maxvalue - minvalue + 1) / int(num.size()) + 1;
        for (int i = 0; i < n; ++i) {
            int idx = (num[i] - minvalue) / valsize;
            interval[idx].first = min(interval[idx].first, num[i]);
            interval[idx].second = max(interval[idx].second, num[i]);
        }
        int result = 0, x = interval[0].first;
        for (int i = 0; i < n; ++i) {
            if (interval[i].second != -1) {
                result = max(result, interval[i].first - x);
                x = interval[i].second;
            }
        }
        return result;
    }
}; 
\end{lstlisting}


\subsection{ Maximum Product Subarray }
\label{ Maximum Product Subarray }

\subsubsection*{Problem Description}
Find the contiguous subarray within an array (containing at least one number) which has the largest product.

For example, given the array \textbf{[2,3,-2,4]},


the contiguous subarray \textbf{[2,3]} has the largest product = \textbf{6}.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Dynamic Programming ]{ Dynamic Programming }


\rightline{\href{https://oj.leetcode.com/problems/maximum-product-subarray/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int maxProduct(int A[], int n) {
        if (n <= 0) return 0;
        int maxa = A[0], mina = A[0], maxp = A[0];
        for (int i = 1; i < n; ++i) {
            int maxt = maxa * A[i];
            int mint = mina * A[i];
            maxa = std::max(std::max(maxt, mint), A[i]);
            mina = std::min(std::min(maxt, mint), A[i]);
            maxp = std::max(maxa, maxp);
        }
        return maxp;
    }
}; 
\end{lstlisting}


\subsection{ Maximum Subarray }
\label{ Maximum Subarray }

\subsubsection*{Problem Description}
Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array \textbf{[−2,1,−3,4,−1,2,1,−5,4]},


the contiguous subarray \textbf{[4,−1,2,1]} has the largest sum = \textbf{6}.

If you have figured out the O(\emph{n}) solution, try coding another solution using the divide and conquer approach, which is more subtle.


\textbf{Tags: }
\hyperref[ Divide and Conquer ]{ Divide and Conquer },  \hyperref[ Array ]{ Array },  \hyperref[ Dynamic Programming ]{ Dynamic Programming }


\rightline{\href{https://oj.leetcode.com/problems/maximum-subarray/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int maxSubArray(int A[], int n) {
        if (n <= 0) return 0;
        int ans = A[0], sum = A[0];
        for (int i = 1; i < n; ++i) {
            sum = max(sum, 0) + A[i];
            ans = max(ans, sum);
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Median of Two Sorted Arrays }
\label{ Median of Two Sorted Arrays }

\subsubsection*{Problem Description}
There are two sorted arrays A and B of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).


\textbf{Tags: }
\hyperref[ Divide and Conquer ]{ Divide and Conquer },  \hyperref[ Array ]{ Array },  \hyperref[ Binary Search ]{ Binary Search }


\rightline{\href{https://oj.leetcode.com/problems/median-of-two-sorted-arrays/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}

class Solution {
public:
    double findMedianSortedArrays(int A[], int m, int B[], int n) {
        double ans = findKth(A, m, B, n, (n + m) / 2 + 1);
        if ((n + m) % 2 == 0) {
            ans = ans * 0.5 + findKth(A, m, B, n, (n + m) / 2) * 0.5;
        }
        return ans;
    }
private:
    int findKth(int A[], int m, int B[], int n, int k) {
        if (n == 0) return A[k - 1];
        if (m == 0) return B[k - 1];
        int mid = (m - 1) / 2;
        int pos = lower_bound(B, B + n, A[mid]) - B;
        if (mid + 1 + pos > k) {
            return findKth(A, mid, B, pos, k);
        }
        if (mid + 1 + pos < k) {
            return findKth(A + mid + 1, m - mid - 1, B + pos, n - pos, k - mid - 1 - pos);
        }
        return A[mid];
    }
};

\end{lstlisting}


\subsection{ Merge Intervals }
\label{ Merge Intervals }

\subsubsection*{Problem Description}
Given a collection of intervals, merge all overlapping intervals.

For example,


Given \textbf{[1,3],[2,6],[8,10],[15,18]},


return \textbf{[1,6],[8,10],[15,18]}.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Sort ]{ Sort }


\rightline{\href{https://oj.leetcode.com/problems/merge-intervals/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
 
class Solution {
public:
    vector<Interval> merge(vector<Interval> &intervals) {
        vector<Interval> ans;
        if (intervals.size() == 0) return ans;
        sort(intervals.begin(), intervals.end(), cmp);
        Interval node(intervals[0].start, intervals[0].end);
        for (int i = 1; i < intervals.size(); ++i) {
            if (node.end < intervals[i].start) {
                ans.push_back(node);
                node = intervals[i];
            } else {
                node.end = max(node.end, intervals[i].end);
            }
        }
        ans.push_back(node);
        return ans;
    }
private:
    static bool cmp(const Interval &a, const Interval &b) {
        return a.start < b.start;
    }
}; 
\end{lstlisting}


\subsection{ Merge k Sorted Lists }
\label{ Merge k Sorted Lists }

\subsubsection*{Problem Description}
Merge \emph{k} sorted linked lists and return it as one sorted list. Analyze and describe its complexity.


\textbf{Tags: }
\hyperref[ Divide and Conquer ]{ Divide and Conquer },  \hyperref[ Linked List ]{ Linked List },  \hyperref[ Heap ]{ Heap }


\rightline{\href{https://oj.leetcode.com/problems/merge-k-sorted-lists/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
 
struct Pointer {
    ListNode *p;
    Pointer() {}
    Pointer(ListNode *p): p(p) {} 
    bool operator < (const Pointer &other) const {
        if (p && other.p) return p->val > other.p->val;
        return p < other.p;
    }
};

class Solution {
public:
    ListNode *mergeKLists(vector<ListNode *> &lists) {
        priority_queue<Pointer> que;
        ListNode head(0), *tail;
        tail = &head;
        for (int i = 0; i < lists.size(); ++i) {
            que.push(Pointer(lists[i]));
        }
        while(!que.empty()) {
            Pointer now = que.top();
            que.pop();
            if (now.p) {
                tail->next = now.p;
                tail = tail->next;
                que.push((now.p)->next);
            }
        }
        return head.next;
    }
}; 
\end{lstlisting}


\subsection{ Merge Sorted Array }
\label{ Merge Sorted Array }

\subsubsection*{Problem Description}
Given two sorted integer arrays A and B, merge B into A as one sorted array.

\textbf{Note:}


You may assume that A has enough space (size that is greater or equal to \emph{m} + \emph{n}) to hold additional elements from B. The number of elements initialized in A and B are \emph{m} and \emph{n} respectively.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Two Pointers ]{ Two Pointers }


\rightline{\href{https://oj.leetcode.com/problems/merge-sorted-array/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    void merge(int A[], int m, int B[], int n) {
        for (int i = m + n - 1; i >= 0; --i) {
            int k;
            if (m && n) {
                if (A[m - 1] >= B[n - 1]) {
                    k = A[--m];
                } else {
                    k = B[--n];
                }
            } else if (m && !n) {
                k = A[--m];
            } else if (!m && n) {
                k = B[--n];
            }
            A[i] = k;
        }
    }
}; 
\end{lstlisting}


\subsection{ Merge Two Sorted Lists }
\label{ Merge Two Sorted Lists }

\subsubsection*{Problem Description}
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.


\textbf{Tags: }
\hyperref[ Linked List ]{ Linked List }


\rightline{\href{https://oj.leetcode.com/problems/merge-two-sorted-lists/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
        ListNode head(0), *p;
        p = &head;
        while (l1 || l2) {
            if (l1 && l2) {
                if (l1->val < l2->val) {
                    p->next = l1, l1 = l1->next;
                } else {
                    p->next = l2, l2 = l2->next;
                }
            } else if (!l1 && l2) {
                p->next = l2, l2 = l2->next;
            } else if (l1 && !l2) {
                p->next = l1, l1 = l1->next;
            }
            p = p->next;
        }
        return head.next;
    }
}; 
\end{lstlisting}


\subsection{ Min Stack }
\label{ Min Stack }

\subsubsection*{Problem Description}
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
\begin{itemize}
\item 
push(x) -- Push element x onto stack.

\item 
pop() -- Removes the element on top of the stack.

\item 
top() -- Get the top element.

\item 
getMin() -- Retrieve the minimum element in the stack.

\end{itemize}


\textbf{Tags: }
\hyperref[ Stack ]{ Stack },  \hyperref[ Data Structure ]{ Data Structure }


\rightline{\href{https://oj.leetcode.com/problems/min-stack/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class MinStack {
public:
    void push(int x) {
        if (stk.size() == 0 || x <= minvalue) {
            stk.push(minvalue);
            minvalue = x;
        }
        stk.push(x);
    }
    
    void pop() {
        int popvalue = stk.top();
        stk.pop();
        if (popvalue == minvalue) {
            minvalue = stk.top();
            stk.pop();
        }
    }
    
    int top() {
        return stk.top();
    }
    
    int getMin() {
        return minvalue;
    }
    
private:
    stack<int> stk;
    int minvalue;
}; 
\end{lstlisting}


\subsection{ Minimum Depth of Binary Tree }
\label{ Minimum Depth of Binary Tree }

\subsubsection*{Problem Description}
Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Depth-first Search ]{ Depth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/minimum-depth-of-binary-tree/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode *root) {
        if (root == NULL) return 0;
        if (root->left == NULL && root->right == NULL) return 1;
        int ans = LONG_MAX;
        if (root->left) {
            ans = min(ans, minDepth(root->left) + 1);
        }
        if (root->right) {
            ans = min(ans, minDepth(root->right) + 1);
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Minimum Path Sum }
\label{ Minimum Path Sum }

\subsubsection*{Problem Description}
Given a \emph{m} x \emph{n} grid filled with non-negative numbers, find a path from top left to bottom right which \emph{minimizes} the sum of all numbers along its path.

\textbf{Note:} You can only move either down or right at any point in time.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Dynamic Programming ]{ Dynamic Programming }


\rightline{\href{https://oj.leetcode.com/problems/minimum-path-sum/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int minPathSum(vector<vector<int> > &grid) {
        int n = grid.size(), m = grid[0].size();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (i && j) {
                    grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);
                } else if (!i && j) {
                    grid[i][j] += grid[i][j - 1];
                } else if (i && !j) {
                    grid[i][j] += grid[i - 1][j];
                }
            }
        }
        return grid[n - 1][m - 1];
    }
}; 
\end{lstlisting}


\subsection{ Minimum Window Substring }
\label{ Minimum Window Substring }

\subsubsection*{Problem Description}
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).

For example,


\textbf{S} = \textbf{"ADOBECODEBANC"}


\textbf{T} = \textbf{"ABC"}

Minimum window is \textbf{"BANC"}.

\textbf{Note:}


If there is no such window in S that covers all characters in T, return the emtpy string \textbf{""}.

If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.


\textbf{Tags: }
\hyperref[ Hash Table ]{ Hash Table },  \hyperref[ Two Pointers ]{ Two Pointers },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/minimum-window-substring/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    string minWindow(string S, string T) {
        vector<int> cnt(256, 0);
        int cnttype = 0;
        for (int i = 0; i < T.size(); ++i) {
            if (cnt[T[i]] == 0) {
                -- cnttype;
            }
            -- cnt[T[i]];
        }
        int ansx = 0, anslen = S.size() + 1, x = 0;
        for (int i = 0; i < S.size(); ++i) {
            ++ cnt[S[i]];
            if (cnt[S[i]] == 0) {
                ++ cnttype;
            }
            while(cnttype == 0) {
                if (cnt[S[x]] == 0) {
                    -- cnttype;
                }
                if (anslen > i - x) {
                    ansx = x;
                    anslen = i - x + 1;
                }
                -- cnt[S[x++]];
            }
        }
        if (anslen == S.size() + 1) return "";
        return S.substr(ansx, anslen);
    }
}; 
\end{lstlisting}


\subsection{ Multiply Strings }
\label{ Multiply Strings }

\subsubsection*{Problem Description}
Given two numbers represented as strings, return multiplication of the numbers as a string.

Note: The numbers can be arbitrarily large and are non-negative.


\textbf{Tags: }
\hyperref[ Math ]{ Math },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/multiply-strings/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    string multiply(string num1, string num2) {
        string ans;
        num1 = string(num1.rbegin(), num1.rend());
        num2 = string(num2.rbegin(), num2.rend());
        
        for (int i = 0; i < num1.size(); ++i) {
            ans = add(ans, multiply(num2, num1[i] - '0'), i);
        }
        while(ans.size() >= 2 && ans[ans.size() - 1] == '0') ans.pop_back();
        return string(ans.rbegin(), ans.rend());
    }
    
private:
    string multiply(string num1, int n2) {
        int c = 0;
        for (int i = 0; i < num1.size(); ++i) {
            c += (num1[i] - '0') * n2;
            num1[i] = c % 10 + '0';
            c /= 10;
        }
        if (c) {
            num1.push_back(c + '0');
        }
        return num1;
    }
    
    string add(string num1, string num2, int pow) {
        string ans;
        int c = 0;
        for (int i = 0, j = -pow; i < num1.size() || j < num2.size(); ++i, ++j) {
            if (i < num1.size()) {
                c += num1[i] - '0';
            }
            if (0 <= j && j < num2.size()) {
                c += num2[j] - '0';
            }
            ans.push_back(c % 10 + '0');
            c /= 10;
        }
        if (c) {
            ans.push_back(c + '0');
        }
        return ans;
    }
};


\end{lstlisting}


\subsection{ N-Queens II }
\label{ N-Queens II }

\subsubsection*{Problem Description}
Follow up for N-Queens problem.

Now, instead outputting board configurations, return the total number of distinct solutions.




\textbf{Tags: }
\hyperref[ Backtracking ]{ Backtracking }


\rightline{\href{https://oj.leetcode.com/problems/n-queens-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int totalNQueens(int n) {
        return _DFS(0, n, 0, 0, 0);
    }
private:
    int _DFS(int k, int n, int left, int right, int up) {
        if (k == n) {
            return 1;
        }
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            if (!(left & 1<<i) && !(right & 1<<i) && !(up & 1<<i)) {
                ans += _DFS(k + 1, n, (left | 1<<i) << 1, (right | 1<<i) >> 1, (up | 1<<i));
            }
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ N-Queens }
\label{ N-Queens }

\subsubsection*{Problem Description}
The \emph{n}-queens puzzle is the problem of placing \emph{n} queens on an \emph{n}×\emph{n} chessboard such that no two queens attack each other.



Given an integer \emph{n}, return all distinct solutions to the \emph{n}-queens puzzle.

Each solution contains a distinct board configuration of the \emph{n}-queens' placement, where \textbf{'Q'} and \textbf{'.'} both indicate a queen and an empty space respectively.

For example,


There exist two distinct solutions to the 4-queens puzzle:

\begin{verbatim}
[
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]
\end{verbatim}

\textbf{Tags: }
\hyperref[ Backtracking ]{ Backtracking }


\rightline{\href{https://oj.leetcode.com/problems/n-queens/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<vector<string> > solveNQueens(int n) {
        ans.clear();
        now.clear();
        _DFS(0, n, 0, 0, 0);
        return ans;
    }
private:
    void _DFS(int k, int n, int left, int right, int up) {
        if (k == n) {
            _gen(n);
        }
        for (int i = 0; i < n; ++i) {
            if (!(left & 1<<i) && !(right & 1<<i) && !(up & 1<<i)) {
                now.push_back(i);
                _DFS(k + 1, n, (left | 1<<i) << 1, (right | 1<<i) >> 1, (up | 1<<i));
                now.pop_back();
            }
        }
    }
    void _gen(int n) {
        vector<string> solve;
        string line(n, '.');
        for (int i = 0; i < n; ++i) {
            line[now[i]] = 'Q';
            solve.push_back(line);
            line[now[i]] = '.';
        }
        ans.push_back(solve);
    }
    vector<vector<string> > ans;
    vector<int> now;
}; 
\end{lstlisting}


\subsection{ Next Permutation }
\label{ Next Permutation }

\subsubsection*{Problem Description}
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place, do not allocate extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.


\textbf{1,2,3} → \textbf{1,3,2}


\textbf{3,2,1} → \textbf{1,2,3}


\textbf{1,1,5} → \textbf{1,5,1}


\textbf{Tags: }
\hyperref[ Array ]{ Array }


\rightline{\href{https://oj.leetcode.com/problems/next-permutation/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    void nextPermutation(vector<int> &num) {
        if (next_permutation(num.begin(), num.end()) == false) {
            sort(num.begin(), num.end());
        }
    }
}; 
\end{lstlisting}


\subsection{ Palindrome Number }
\label{ Palindrome Number }

\subsubsection*{Problem Description}
Determine whether an integer is a palindrome. Do this without extra space.

Could negative integers be palindromes? (ie, -1)

If you are thinking of converting the integer to string, note the restriction of using extra space.

You could also try reversing an integer. However, if you have solved the problem "Reverse Integer", you know that the reversed integer might overflow. How would you handle such case?

There is a more generic way of solving this problem.


\textbf{Tags: }
\hyperref[ Math ]{ Math }


\rightline{\href{https://oj.leetcode.com/problems/palindrome-number/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0) return false;
        char s[16], n = 0;
        while(x) {
            s[n++] = x % 10;
            x /= 10;
        }
        for (int i = 0; i < n / 2; ++i) {
            if (s[i] != s[n - i - 1]) return false;
        }
        return true;
    }
}; 
\end{lstlisting}


\subsection{ Palindrome Partitioning II }
\label{ Palindrome Partitioning II }

\subsubsection*{Problem Description}
Given a string \emph{s}, partition \emph{s} such that every substring of the partition is a palindrome.

Return the minimum cuts needed for a palindrome partitioning of \emph{s}.

For example, given \emph{s} = \textbf{"aab"},


Return \textbf{1} since the palindrome partitioning \textbf{["aa","b"]} could be produced using 1 cut.


\textbf{Tags: }
\hyperref[ Dynamic Programming ]{ Dynamic Programming }


\rightline{\href{https://oj.leetcode.com/problems/palindrome-partitioning-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int minCut(string s) {
        int n = s.size();
        vector<vector<bool> > pali(s.size(), vector<bool> (s.size() + 1, false));
        for (int i = 0; i < n; ++i) {
            pali[i][i] = pali[i][i + 1] = true;
        }
        for (int len = 2; len <= n; ++len) {
            for (int i = 0; i + len <= n; ++i) {
                int j = i + len;
                if (s[i] == s[j - 1] && pali[i + 1][j - 1]) {
                    pali[i][j] = true;
                }
            }
        }
        vector<int> f(n + 1, n + 1);
        f[0] = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (pali[j][i]) {
                    f[i] = min(f[i], f[j] + 1);
                }
            }
        }
        return f[n] - 1;
    }
}; 
\end{lstlisting}


\subsection{ Palindrome Partitioning }
\label{ Palindrome Partitioning }

\subsubsection*{Problem Description}
Given a string \emph{s}, partition \emph{s} such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of \emph{s}.

For example, given \emph{s} = \textbf{"aab"},



Return
\begin{verbatim}
  [
    ["aa","b"],
    ["a","a","b"]
  ]
\end{verbatim}


\textbf{Tags: }
\hyperref[ Backtracking ]{ Backtracking }


\rightline{\href{https://oj.leetcode.com/problems/palindrome-partitioning/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<vector<string>> partition(string s) {
        int n = s.size();
        vector<vector<bool> > pali(s.size(), vector<bool> (s.size() + 1, false));
        for (int i = 0; i < n; ++i) {
            pali[i][i] = pali[i][i + 1] = true;
        }
        for (int len = 2; len <= n; ++len) {
            for (int i = 0; i + len <= n; ++i) {
                int j = i + len;
                if (s[i] == s[j - 1] && pali[i + 1][j - 1]) {
                    pali[i][j] = true;
                }
            }
        }
        vector<vector<string> > ans;
        vector<string> now;
        _gen(s, 0, pali, ans, now);
        return ans;
    }
private:
    void _gen(string &s, int k, vector<vector<bool> > &pali, vector<vector<string>> &ans, vector<string> &now) {
        if (k == s.size()) {
            ans.push_back(now);
            return ;
        }
        for (int i = k + 1; i <= s.size(); ++i) {
            if (pali[k][i]) {
                now.push_back(s.substr(k, i - k));
                _gen(s, i, pali, ans, now);
                now.pop_back();
            }
        }
    }
}; 
\end{lstlisting}


\subsection{ Partition List }
\label{ Partition List }

\subsubsection*{Problem Description}
Given a linked list and a value \emph{x}, partition it such that all nodes less than \emph{x} come before nodes greater than or equal to \emph{x}.

You should preserve the original relative order of the nodes in each of the two partitions.

For example,


Given \textbf{1-$>$4-$>$3-$>$2-$>$5-$>$2} and \emph{x} = 3,


return \textbf{1-$>$2-$>$2-$>$4-$>$3-$>$5}.


\textbf{Tags: }
\hyperref[ Linked List ]{ Linked List },  \hyperref[ Two Pointers ]{ Two Pointers }


\rightline{\href{https://oj.leetcode.com/problems/partition-list/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *partition(ListNode *head, int x) {
        ListNode h1(0), *p1, h2(0), *p2;
        p1 = &h1, p2 = &h2;
        for (ListNode *p3 = head; p3; p3 = p3->next) {
            if (p3->val < x) {
                p1->next = p3;
                p1 = p1->next;
            } else {
                p2->next = p3;
                p2 = p2->next;
            }
        }
        p1->next = h2.next;
        p2->next = NULL;
        return h1.next;
    }
}; 
\end{lstlisting}


\subsection{ Pascal's Triangle II }
\label{ Pascal's Triangle II }

\subsubsection*{Problem Description}

\textbf{Tags: }


\rightline{\href{https://oj.leetcode.com/problems/pascal's-triangle-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> line(rowIndex + 1, 1);
        long long c = 1;
        for (int i = 1; i < rowIndex; ++i) {
            c = c * (rowIndex - i + 1) / i;
            line[i] = c;
        }
        return line;
    }
}; 
\end{lstlisting}


\subsection{ Pascal's Triangle }
\label{ Pascal's Triangle }

\subsubsection*{Problem Description}

\textbf{Tags: }


\rightline{\href{https://oj.leetcode.com/problems/pascal's-triangle/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<vector<int> > generate(int numRows) {
        vector<vector<int> >pascal;
        if (numRows == 0) return pascal;
        pascal.push_back(vector<int> (1, 1));
        for (int i = 1; i < numRows; ++i) {
            vector<int> &up = pascal[i - 1], line;
            line.push_back(1);
            for (int i = 1; i < up.size(); ++i) {
                line.push_back(up[i - 1] + up[i]);
            }
            line.push_back(1);
            pascal.push_back(line);
        }
        return pascal;
    }
}; 
\end{lstlisting}


\subsection{ Path Sum II }
\label{ Path Sum II }

\subsubsection*{Problem Description}
Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.

return


\begin{verbatim}
[
   [5,4,11,2],
   [5,8,4,5]
]
\end{verbatim}

\begin{verbatim}
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
\end{verbatim}

\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Depth-first Search ]{ Depth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/path-sum-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int> > pathSum(TreeNode *root, int sum) {
        vector<vector<int> > ans;
        vector<int> path;
        getPathSum(root, sum, path, ans);
        return ans;
    }
private:
    void getPathSum(TreeNode *root, int sum, vector<int> &path, vector<vector<int> > &ans) {
        if (root == NULL) return ;
        if (root->left == NULL && root->right == NULL) {
            if (root->val == sum) {
                path.push_back(root->val);
                ans.push_back(path);
                path.pop_back();
            }
            return ;
        }
        path.push_back(root->val);
        getPathSum(root->left, sum - root->val, path, ans);
        getPathSum(root->right, sum - root->val, path, ans);
        path.pop_back();
    }
};

\end{lstlisting}


\subsection{ Path Sum }
\label{ Path Sum }

\subsubsection*{Problem Description}
Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

return true, as there exist a root-to-leaf path \textbf{5-$>$4-$>$11-$>$2} which sum is 22.

\begin{verbatim}
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
\end{verbatim}

\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Depth-first Search ]{ Depth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/path-sum/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode *root, int sum) {
        if (root == NULL) return false;
        if (root->left == NULL && root->right == NULL) {
            return root->val == sum;
        }
        if (hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val)) {
            return true;
        }
        return false;
    }
}; 
\end{lstlisting}


\subsection{ Permutation Sequence }
\label{ Permutation Sequence }

\subsubsection*{Problem Description}
The set \textbf{[1,2,3,…,\emph{n}]} contains a total of \emph{n}! unique permutations.

By listing and labeling all of the permutations in order,


We get the following sequence (ie, for \emph{n} = 3):

\textbf{"123"}
\textbf{"132"}
\textbf{"213"}
\textbf{"231"}
\textbf{"312"}
\textbf{"321"}
\begin{itemize}
\item \textbf{"123"}
\item \textbf{"132"}
\item \textbf{"213"}
\item \textbf{"231"}
\item \textbf{"312"}
\item \textbf{"321"}
\end{itemize}

Given \emph{n} and \emph{k}, return the \emph{k}th permutation sequence.

\textbf{Note:} Given \emph{n} will be between 1 and 9 inclusive.


\textbf{Tags: }
\hyperref[ Backtracking ]{ Backtracking },  \hyperref[ Math ]{ Math }


\rightline{\href{https://oj.leetcode.com/problems/permutation-sequence/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    string getPermutation(int n, int k) {
        vector<bool> select(n + 1, false);
        vector<int> fac(n + 1, 1);
        string s;
        for (int i = 2; i <= n; ++i) {
            fac[i] = fac[i - 1] * i;
        }
        -- k;
        for (int i = n - 1; i >= 0; --i) {
            s.push_back(_get(select, k / fac[i]) + '0');
            k %= fac[i];
        }
        return s;
    }
private:
    int _get(vector<bool> &select, int k) {
        int cnt = 0;
        for (int i = 1; i < select.size(); ++i) {
            if (select[i] == false) {
                ++ cnt;
            }
            if (cnt == k + 1) {
                select[i] = true;
                return i;
            }
        }
        return -1;
    }
};

\end{lstlisting}


\subsection{ Permutations II }
\label{ Permutations II }

\subsubsection*{Problem Description}
Given a collection of numbers that might contain duplicates, return all possible unique permutations.

For example,


\textbf{[1,1,2]} have the following unique permutations:


\textbf{[1,1,2]}, \textbf{[1,2,1]}, and \textbf{[2,1,1]}.


\textbf{Tags: }
\hyperref[ Backtracking ]{ Backtracking }


\rightline{\href{https://oj.leetcode.com/problems/permutations-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<vector<int> > permuteUnique(vector<int> &num) {
        vector<vector<int> > ans;
        sort(num.begin(), num.end());
        do {
            ans.push_back(num);
        } while (next_permutation(num.begin(), num.end()));
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Permutations }
\label{ Permutations }

\subsubsection*{Problem Description}
Given a collection of numbers, return all possible permutations.

For example,


\textbf{[1,2,3]} have the following permutations:


\textbf{[1,2,3]}, \textbf{[1,3,2]}, \textbf{[2,1,3]}, \textbf{[2,3,1]}, \textbf{[3,1,2]}, and \textbf{[3,2,1]}.


\textbf{Tags: }
\hyperref[ Backtracking ]{ Backtracking }


\rightline{\href{https://oj.leetcode.com/problems/permutations/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<vector<int> > permute(vector<int> &num) {
        vector<vector<int> > ans;
        sort(num.begin(), num.end());
        do {
            ans.push_back(num);
        } while (next_permutation(num.begin(), num.end()));
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Plus One }
\label{ Plus One }

\subsubsection*{Problem Description}
Given a non-negative number represented as an array of digits, plus one to the number.

The digits are stored such that the most significant digit is at the head of the list.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Math ]{ Math }


\rightline{\href{https://oj.leetcode.com/problems/plus-one/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<int> plusOne(vector<int> &digits) {
        int c = 1;
        for (int i = digits.size() - 1; i >= 0; --i) {
            c += digits[i];
            digits[i] = c % 10;
            c /= 10;
        }
        if (c) {
            digits.push_back(0);
            for (int i = digits.size() - 1; i; --i) {
                digits[i] = digits[i - 1];
            }
            digits[0] = c;
        }
        return digits;
    }
}; 
\end{lstlisting}


\subsection{ Populating Next Right Pointers in Each Node II }
\label{ Populating Next Right Pointers in Each Node II }

\subsubsection*{Problem Description}
Follow up for problem "\emph{Populating Next Right Pointers in Each Node}".

What if the given tree could be any binary tree? Would your previous solution still work?

\textbf{Note:}
\begin{itemize}
\item You may only use constant extra space.
\end{itemize}

For example,


Given the following binary tree,


\begin{verbatim}
         1
       /  \
      2    3
     / \    \
    4   5    7
\end{verbatim}

After calling your function, the tree should look like:


\begin{verbatim}
         1 -$>$ NULL
       /  \
      2 -$>$ 3 -$>$ NULL
     / \    \
    4-$>$ 5 -$>$ 7 -$>$ NULL
\end{verbatim}


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Depth-first Search ]{ Depth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if (root == NULL) return ;
        TreeLinkNode *head = NULL, *tail = NULL, *p = root;
        for (; p; p = p->next) {
            insertLink(head, tail, p->left);
            insertLink(head, tail, p->right);
        }
        connect(head);
    }
private:
    void insertLink(TreeLinkNode * &head, TreeLinkNode * &tail, TreeLinkNode * node) {
        if (node != NULL) {
            if (head == NULL) {
                head = tail = node;
            } else {
                tail->next = node;
                tail = tail->next;
            }
        }
    }
};

\end{lstlisting}


\subsection{ Populating Next Right Pointers in Each Node }
\label{ Populating Next Right Pointers in Each Node }

\subsubsection*{Problem Description}
Given a binary tree
\begin{verbatim}
    struct TreeLinkNode \{
      TreeLinkNode *left;
      TreeLinkNode *right;
      TreeLinkNode *next;
    \}
\end{verbatim}

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to \textbf{NULL}.

Initially, all next pointers are set to \textbf{NULL}.

\textbf{Note:}
\begin{itemize}
\item You may only use constant extra space.
\item You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).
\end{itemize}

For example,


Given the following perfect binary tree,


\begin{verbatim}
         1
       /  \
      2    3
     / \  / \
    4  5  6  7
\end{verbatim}

After calling your function, the tree should look like:


\begin{verbatim}
         1 -$>$ NULL
       /  \
      2 -$>$ 3 -$>$ NULL
     / \  / \
    4-$>$5-$>$6-$>$7 -$>$ NULL
\end{verbatim}


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Depth-first Search ]{ Depth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if (root == NULL) return ;
        queue<TreeLinkNode *> nodes;
        queue<int> depths;
        nodes.push(root); depths.push(0);
        while (nodes.size()) {
            root = nodes.front();
            int d = depths.front();
            nodes.pop(); depths.pop();
            if (nodes.size() && depths.front() == d) root->next = nodes.front();
            else root->next = NULL;
            if (root->left) {
                nodes.push(root->left); depths.push(d + 1);
            }
            if (root->right) {
                nodes.push(root->right); depths.push(d + 1);
            }
        }
    }
}; 
\end{lstlisting}


\subsection{ Pow(x, n) }
\label{ Pow(x, n) }

\subsubsection*{Problem Description}

\textbf{Tags: }


\rightline{\href{https://oj.leetcode.com/problems/pow(x,-n)/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    double pow(double x, int n) {
        long long longn = n;
        if (n < 0) return 1 / _pow(x, -longn);
        return _pow(x, n);
    }
private:
    double _pow(double x, long long n) {
        double ans = 1.0;
        while (n) {
            if (n % 2) ans *= x;
            x *= x;
            n >>= 1;
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Recover Binary Search Tree }
\label{ Recover Binary Search Tree }

\subsubsection*{Problem Description}
Two elements of a binary search tree (BST) are swapped by mistake.

Recover the tree without changing its structure.

The serialization of a binary tree follows a level order traversal, where '\#' signifies a path terminator where no node exists below.

Here's an example:


\begin{verbatim}
   1
  / \
 2   3
    /
   4
    \
     5
\end{verbatim}
The above binary tree is serialized as \textbf{"\{1,2,3,\#,\#,4,\#,\#,5\}"}.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Depth-first Search ]{ Depth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/recover-binary-search-tree/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void recoverTree(TreeNode *root) {
        if (root == NULL) return ;
        TreeNode *mistakeroot, *minp, *maxp, *lminp, *lmaxp, *rminp, *rmaxp;
        mistakeroot = _mistake(root, minp, maxp);
        
        _mistake(mistakeroot->left, lminp, lmaxp);
        _mistake(mistakeroot->right, rminp, rmaxp);
        
        if ((lmaxp && lmaxp->val > mistakeroot->val) && (rminp && rminp->val < mistakeroot->val)) {
            _swap(lmaxp, rminp);
            return ;
        }
        if (lmaxp && lmaxp->val > mistakeroot->val) {
            _swap(lmaxp, mistakeroot);
        }
        if (rminp && rminp->val < mistakeroot->val) {
            _swap(rminp, mistakeroot);
        }
    }
private:
    void _swap(TreeNode *p, TreeNode *q) {
        int temp = p->val;
        p->val = q->val;
        q->val = temp;
    }
    
    TreeNode* _mistake(TreeNode *root, TreeNode *&minp, TreeNode *&maxp) {
        if (root == NULL) {
            minp = maxp = NULL;
            return NULL;
        }
    
        TreeNode *lminp, *rminp, *lmaxp, *rmaxp, *lmistake, *rmistake;
        
        lmistake = _mistake(root->left, lminp, lmaxp);
        rmistake = _mistake(root->right, rminp, rmaxp);
        
        minp = maxp = root;
        if (lminp && lminp->val < minp->val) minp = lminp;
        if (rminp && rminp->val < minp->val) minp = rminp;
        if (lmaxp && lmaxp->val > maxp->val) maxp = lmaxp;
        if (rmaxp && rmaxp->val > maxp->val) maxp = rmaxp;
        
        
        if ((lmaxp && lmaxp->val > root->val) || (rminp && rminp->val < root->val)) return root;
        if (lmistake) return lmistake;
        if (rmistake) return rmistake;
        return NULL;
    }
}; 
\end{lstlisting}


\subsection{ Regular Expression Matching }
\label{ Regular Expression Matching }

\subsubsection*{Problem Description}
Implement regular expression matching with support for \textbf{'.'} and \textbf{'*'}.

\begin{verbatim}
'.' Matches any single character.
'*' Matches zero or more of the preceding element.

The matching should cover the <b>entire</b> input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true
\end{verbatim}

\textbf{Tags: }
\hyperref[ Dynamic Programming ]{ Dynamic Programming },  \hyperref[ Backtracking ]{ Backtracking },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/regular-expression-matching/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    bool isMatch(const char *s, const char *p) {
        int n = strlen(s), m = strlen(p);
        vector<vector<bool> > f(n + 1, vector<bool> (m + 1, false));
        f[0][0] = true;
        for (int i = 0; i <= n; ++i) {
            for (int j = 0; j <= m; ++j) {
                if (i && j && p[j - 1] == '.') {
                    f[i][j] = f[i - 1][j - 1];
                } else if (j >= 2 && p[j - 1] == '*') {
                    if (p[j - 2] == '.') {
                        f[i][j] = (f[i][j - 2] || (i && f[i - 1][j]));
                    } else {
                        f[i][j] = (f[i][j - 2] || (i && s[i - 1] == p[j - 2] && f[i - 1][j]));
                    }
                } else if (i && j){
                    f[i][j] = (f[i - 1][j - 1] && s[i - 1] == p[j - 1]);
                }
            }
        }
        return f[n][m];
    }
}; 
\end{lstlisting}


\subsection{ Remove Duplicates from Sorted Array II }
\label{ Remove Duplicates from Sorted Array II }

\subsubsection*{Problem Description}
Follow up for "Remove Duplicates":


What if duplicates are allowed at most \emph{twice}?

For example,


Given sorted array A = \textbf{[1,1,1,2,2,3]},

Your function should return length = \textbf{5}, and A is now \textbf{[1,1,2,2,3]}.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Two Pointers ]{ Two Pointers }


\rightline{\href{https://oj.leetcode.com/problems/remove-duplicates-from-sorted-array-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int removeDuplicates(int A[], int n) {
        if (n <= 2) return n;
        int m = 2;
        for (int i = 2; i < n; ++i) {
            if (A[m - 2] != A[i]) {
                A[m++] = A[i];
            }
        }
        return m;
    }
}; 
\end{lstlisting}


\subsection{ Remove Duplicates from Sorted Array }
\label{ Remove Duplicates from Sorted Array }

\subsubsection*{Problem Description}
Given a sorted array, remove the duplicates in place such that each element appear only \emph{once} and return the new length.

Do not allocate extra space for another array, you must do this in place with constant memory.

For example,


Given input array A = \textbf{[1,1,2]},

Your function should return length = \textbf{2}, and A is now \textbf{[1,2]}.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Two Pointers ]{ Two Pointers }


\rightline{\href{https://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int removeDuplicates(int A[], int n) {
        if (n == 0) return 0;
        int m = 1;
        for (int i = 1; i < n; ++i) {
            if (A[m - 1] != A[i]) A[m++] = A[i];
        }
        return m;
    }
}; 
\end{lstlisting}


\subsection{ Remove Duplicates from Sorted List II }
\label{ Remove Duplicates from Sorted List II }

\subsubsection*{Problem Description}
Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only \emph{distinct} numbers from the original list.

For example,


Given \textbf{1-$>$2-$>$3-$>$3-$>$4-$>$4-$>$5}, return \textbf{1-$>$2-$>$5}.


Given \textbf{1-$>$1-$>$1-$>$2-$>$3}, return \textbf{2-$>$3}.


\textbf{Tags: }
\hyperref[ Linked List ]{ Linked List }


\rightline{\href{https://oj.leetcode.com/problems/remove-duplicates-from-sorted-list-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *deleteDuplicates(ListNode *head) {
        ListNode newhead(0);
        newhead.next = head;
        
        ListNode *pre = &newhead, *p = head;
        while (p && p->next) {
            bool needdelete = false;
            while(p->next && p->val == p->next->val) {
                p->next = p->next->next;
                needdelete = true;
            }
            if (needdelete) {
                pre->next = p->next;
                p = pre->next;
            } else {
                pre = p;
                p = p->next;
            }
        }
        return newhead.next;
    }
}; 
\end{lstlisting}


\subsection{ Remove Duplicates from Sorted List }
\label{ Remove Duplicates from Sorted List }

\subsubsection*{Problem Description}
Given a sorted linked list, delete all duplicates such that each element appear only \emph{once}.

For example,


Given \textbf{1-$>$1-$>$2}, return \textbf{1-$>$2}.


Given \textbf{1-$>$1-$>$2-$>$3-$>$3}, return \textbf{1-$>$2-$>$3}.


\textbf{Tags: }
\hyperref[ Linked List ]{ Linked List }


\rightline{\href{https://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *deleteDuplicates(ListNode *head) {
        if (head == NULL) return head;
        ListNode *p = head, *q;
        while(p->next) {
            if (p->val == p->next->val) {
                q = p->next;
                p->next = q->next;
                delete q;
            } else {
                p = p->next;
            }
        }
        return head;
    }
}; 
\end{lstlisting}


\subsection{ Remove Element }
\label{ Remove Element }

\subsubsection*{Problem Description}
Given an array and a value, remove all instances of that value in place and return the new length.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Two Pointers ]{ Two Pointers }


\rightline{\href{https://oj.leetcode.com/problems/remove-element/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int removeElement(int A[], int n, int elem) {
        int m = 0;
        for (int i = 0; i < n; ++i) {
            if (A[i] != elem) A[m++] = A[i];
        }
        return m;
    }
}; 
\end{lstlisting}


\subsection{ Remove Nth Node From End of List }
\label{ Remove Nth Node From End of List }

\subsubsection*{Problem Description}
Given a linked list, remove the \emph{n}th node from the end of list and return its head.

For example,

\textbf{Note:}


Given \emph{n} will always be valid.


Try to do this in one pass.

\begin{verbatim}
   Given linked list: <b>1->2->3->4->5</b>, and <b><i>n</i> = 2</b>.

   After removing the second node from the end, the linked list becomes <b>1->2->3->5</b>.
\end{verbatim}

\textbf{Tags: }
\hyperref[ Linked List ]{ Linked List },  \hyperref[ Two Pointers ]{ Two Pointers }


\rightline{\href{https://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

class Solution {
public:
    ListNode *removeNthFromEnd(ListNode *head, int n) {
        if (head == NULL || n <= 0) return head;
        ListNode newhead(0), *p, *q = head;
        int diff = 0;
        newhead.next = head;
        p = &newhead;
        for (; q; q = q->next) {
            if (diff == n) {
                p = p->next;
            } else {
                ++ diff;
            }
        }
        q = p->next;
        p->next = q->next;
        delete q;
        return newhead.next;
    }
}; 
\end{lstlisting}


\subsection{ Reorder List }
\label{ Reorder List }

\subsubsection*{Problem Description}
Given a singly linked list \emph{L}: \emph{L}0→\emph{L}1→…→\emph{L}\emph{n}-1→\emph{L}n,
reorder it to: \emph{L}0→\emph{L}\emph{n}→\emph{L}1→\emph{L}\emph{n}-1→\emph{L}2→\emph{L}\emph{n}-2→…

You must do this in-place without altering the nodes' values.

For example,
Given \textbf{\{1,2,3,4\}}, reorder it to \textbf{\{1,4,2,3\}}.


\textbf{Tags: }
\hyperref[ Linked List ]{ Linked List }


\rightline{\href{https://oj.leetcode.com/problems/reorder-list/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode *head) {
        if (head == NULL || head->next == NULL) return;
        
        ListNode *h1, *h2;
        cut(head, h1, h2);
        h2 = reverse(h2);
        for (ListNode *p, *q; h2; h1 = p, h2 = q) {
            p = h1->next;
            q = h2->next;
            h1->next = h2;
            h2->next = p;
        }
    }
private:
    ListNode *reverse(ListNode *head) {
        ListNode *p1 = NULL, *p2 = head, *p3;
        for (; p2; p1 = p2, p2 = p3) {
            p3 = p2->next;
            p2->next = p1;
        }
        return p1;
    }
    void cut(ListNode *head, ListNode* &h1, ListNode* &h2) {
        ListNode* p;
        p = h1 = h2 = head;
        for (int i = 0; p != NULL; ++i, p = p->next) {
            if (i && i % 2 == 0) {
                h2 = h2->next;
            }
        }
        p = h2, h2 = h2->next, p->next = NULL;
    }
}; 
\end{lstlisting}


\subsection{ Restore IP Addresses }
\label{ Restore IP Addresses }

\subsubsection*{Problem Description}
Given a string containing only digits, restore it by returning all possible valid IP address combinations.

For example:


Given \textbf{"25525511135"},

return \textbf{["255.255.11.135", "255.255.111.35"]}. (Order does not matter)


\textbf{Tags: }
\hyperref[ Backtracking ]{ Backtracking },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/restore-ip-addresses/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        ans.clear();
        now.clear();
        if (s.size() > 12) return ans;
        _DFS(s, 0);
        return ans;
    }
private:
    void _DFS(string &s, int k) {
        if (now.size() == 4 || k == s.size()) {
            if (now.size() == 4 && k == s.size()) {
                ans.push_back(now[0] + "." + now[1] + "." + now[2] + "." + now[3]);
            }
            return ;
        }
        if (s[k] == '0') {
            now.push_back("0");
            _DFS(s, k + 1);
            now.pop_back();
        } else {
            string block = "";
            int value = 0;
            for (int i = k; i < s.size(); ++i) {
                value = value * 10 + s[i] - '0';
                if (value < 256) {
                    block.push_back(s[i]);
                    now.push_back(block);
                    _DFS(s, i + 1);
                    now.pop_back();
                }
            }
        }
        
    }
    vector<string> ans, now;
}; 
\end{lstlisting}


\subsection{ Reverse Integer }
\label{ Reverse Integer }

\subsubsection*{Problem Description}
Reverse digits of an integer.

Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!

If the integer's last digit is 0, what should the output be? ie, cases such as 10, 100.

Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?

For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.

\textbf{Update (2014-11-10):}
Test cases had been added to test the overflow behavior.


\textbf{Tags: }
\hyperref[ Math ]{ Math }


\rightline{\href{https://oj.leetcode.com/problems/reverse-integer/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int reverse(int x) {
        long long y = x;
        if (y >= 0) {
            return _reverse(y);
        }
        return - _reverse(-y);
    }
private:
    long long _reverse(long long x) {
        int a[32], n = 0;
        long long ans = 0;
        while (x) {
            a[n++] = x % 10;
            x /= 10;
        }
        for (int i = 0; i < n; ++i) {
            ans = ans * 10 + a[i];
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Reverse Linked List II }
\label{ Reverse Linked List II }

\subsubsection*{Problem Description}
Reverse a linked list from position \emph{m} to \emph{n}. Do it in-place and in one-pass.

For example:


Given \textbf{1-$>$2-$>$3-$>$4-$>$5-$>$NULL}, \emph{m} = 2 and \emph{n} = 4,

return \textbf{1-$>$4-$>$3-$>$2-$>$5-$>$NULL}.

\textbf{Note:}


Given \emph{m}, \emph{n} satisfy the following condition:


1 ≤ \emph{m} ≤ \emph{n} ≤ length of list.


\textbf{Tags: }
\hyperref[ Linked List ]{ Linked List }


\rightline{\href{https://oj.leetcode.com/problems/reverse-linked-list-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *reverseBetween(ListNode *head, int m, int n) {
        ListNode newhead(0), *pre, *p, *q;
        newhead.next = head;
        pre = &newhead;
        p = head;
        for (int i = 1; i < m; ++i) {
            pre = p, p = p->next;
        }
        for (int i = m; i < n; ++i) {
            q = p->next;
            p->next = q->next;
            q->next = pre->next;
            pre->next = q;
        }
        return newhead.next;
    }
}; 
\end{lstlisting}


\subsection{ Reverse Nodes in k-Group }
\label{ Reverse Nodes in k-Group }

\subsubsection*{Problem Description}
Given a linked list, reverse the nodes of a linked list \emph{k} at a time and return its modified list.

If the number of nodes is not a multiple of \emph{k} then left-out nodes in the end should remain as it is.

You may not alter the values in the nodes, only nodes itself may be changed.

Only constant memory is allowed.

For example,


Given this linked list: \textbf{1-$>$2-$>$3-$>$4-$>$5}

For \emph{k} = 2, you should return: \textbf{2-$>$1-$>$4-$>$3-$>$5}

For \emph{k} = 3, you should return: \textbf{3-$>$2-$>$1-$>$4-$>$5}


\textbf{Tags: }
\hyperref[ Linked List ]{ Linked List }


\rightline{\href{https://oj.leetcode.com/problems/reverse-nodes-in-k-group/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *reverseKGroup(ListNode *head, int k) {
        ListNode newhead(0), *pre;
        newhead.next = head;
        pre = &newhead;
        for (ListNode *p = head; p; pre = p, p = p->next) {
            ListNode *tail = p;
            for (int i = 1; i < k && tail; ++i) tail = tail->next;
            if (tail == NULL) break;
            tail = p->next;
            for (int i = 1; i < k; ++i) {
                p->next = tail->next;
                tail->next = pre->next;
                pre->next = tail;
                tail = p->next;
            }
        }
        return newhead.next;
    }
}; 
\end{lstlisting}


\subsection{ Reverse Words in a String }
\label{ Reverse Words in a String }

\subsubsection*{Problem Description}
Given an input string, reverse the string word by word.

For example,
Given s = "\textbf{the sky is blue}",
return "\textbf{blue is sky the}".

\begin{itemize}
\item What constitutes a word?
A sequence of non-space characters constitutes a word.
\item Could the input string contain leading or trailing spaces?
Yes. However, your reversed string should not contain leading or trailing spaces.
\item How about multiple spaces between two words?
Reduce them to a single space in the reversed string.
\end{itemize}


\textbf{Tags: }
\hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/reverse-words-in-a-string/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    void reverseWords(string &s) {
        int n = s.length();
        reverse(s);
        for (int i = 0; i < n; ++i) {
            if (isalpha(s[i])) {
                int p = i + 1;
                while (p < n && isalpha(s[p])) ++p;
                reverse(s, i, p - i);
                i = p;
            }
        }
        int m = 0;
        for (int i = 0; i < n; ++i) {
            if (s[i] != ' ' || s[i] == ' ' && m && s[m - 1] != ' ') {
                s[m ++] = s[i];
            }
        }
        if (s[m - 1] == ' ') -- m;
        s.resize(m);
    }
private:
    bool isalpha(char c) {
        return c != ' ';
    }
    void reverse(string &s, int start = 0, int len = INT_MAX) {
        len = std::min(len, int(s.length()) - start);
        for (int i = 0, p = start, q = start + len - 1; i < len / 2; ++i, ++p, --q) {
            s[p] ^= s[q] ^= s[p] ^= s[q];
        }
    }
}; 
\end{lstlisting}


\subsection{ Roman to Integer }
\label{ Roman to Integer }

\subsubsection*{Problem Description}
Given a roman numeral, convert it to an integer.

Input is guaranteed to be within the range from 1 to 3999.


\textbf{Tags: }
\hyperref[ Math ]{ Math },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/roman-to-integer/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int romanToInt(string s) {
        int ans = 0;
        const char r1 = 'I', r5 = 'V', r10 = 'X', r50 = 'L', r100 = 'C', r500 = 'D', r1000 = 'M';
        for (int i = 0; i < s.size(); ++i) {
            switch (s[i]) {
                case r1000:
                    ans += 1000;
                    break;
                case r500:
                    ans += 500;
                    break;
                case r100:
                    if (i + 1 < s.size() && (s[i + 1] == r1000 || s[i + 1] == r500)) {
                        ans -= 100;
                    } else {
                        ans += 100;
                    }
                    break;
                case r50:
                    ans += 50;
                    break;
                case r10:
                    if (i + 1 < s.size() && (s[i + 1] == r100 || s[i + 1] == r50)) {
                        ans -= 10;
                    } else {
                        ans += 10;
                    }
                    break;
                case r5:
                    ans += 5;
                    break;
                case r1:
                    if (i + 1 < s.size() && (s[i + 1] == r10 || s[i + 1] == r5)) {
                        ans -= 1;
                    } else {
                        ans += 1;
                    }
            }
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Rotate List }
\label{ Rotate List }

\subsubsection*{Problem Description}
Given a list, rotate the list to the right by \emph{k} places, where \emph{k} is non-negative.

For example:


Given \textbf{1-$>$2-$>$3-$>$4-$>$5-$>$NULL} and \emph{k} = \textbf{2},


return \textbf{4-$>$5-$>$1-$>$2-$>$3-$>$NULL}.


\textbf{Tags: }
\hyperref[ Linked List ]{ Linked List },  \hyperref[ Two Pointers ]{ Two Pointers }


\rightline{\href{https://oj.leetcode.com/problems/rotate-list/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *rotateRight(ListNode *head, int k) {
        if (head == NULL) return head;
        int n = 1;
        ListNode *tail = head;
        for (; tail->next; tail = tail->next) {
            ++ n;
        }
        tail->next = head;
        k = n - k % n;
        for (int i = 0; i < k; ++i) {
            tail = tail->next;
        }
        head = tail->next;
        tail->next = NULL;
        return head;
    }
}; 
\end{lstlisting}


\subsection{ Same Tree }
\label{ Same Tree }

\subsubsection*{Problem Description}
Given two binary trees, write a function to check if they are equal or not.

Two binary trees are considered equal if they are structurally identical and the nodes have the same value.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Depth-first Search ]{ Depth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/same-tree/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode *p, TreeNode *q) {
        if (p == NULL || q == NULL) {
            return  p == q;
        }
        if (isSameTree(p->left, q->left) && isSameTree(p->right, q->right)) {
            return p->val == q->val;
        }
        return false;
    }
}; 
\end{lstlisting}


\subsection{ Scramble String }
\label{ Scramble String }

\subsubsection*{Problem Description}
Given a string \emph{s1}, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.

Below is one possible representation of \emph{s1} = \textbf{"great"}:

To scramble the string, we may choose any non-leaf node and swap its two children.

For example, if we choose the node \textbf{"gr"} and swap its two children, it produces a scrambled string \textbf{"rgeat"}.

We say that \textbf{"rgeat"} is a scrambled string of \textbf{"great"}.

Similarly, if we continue to swap the children of nodes \textbf{"eat"} and \textbf{"at"}, it produces a scrambled string \textbf{"rgtae"}.

We say that \textbf{"rgtae"} is a scrambled string of \textbf{"great"}.

Given two strings \emph{s1} and \emph{s2} of the same length, determine if \emph{s2} is a scrambled string of \emph{s1}.

\begin{verbatim}
    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
\end{verbatim}
\begin{verbatim}
    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
\end{verbatim}
\begin{verbatim}
    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
\end{verbatim}

\textbf{Tags: }
\hyperref[ Dynamic Programming ]{ Dynamic Programming },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/scramble-string/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    bool isScramble(string s1, string s2) {
        return isScramble(s1.c_str(), s2.c_str(), s1.size());
    }
private:
    bool isScramble(const char *s1, const char *s2, int n) {
        if (n == 0) return true;
        if (n == 1) return s1[0] == s2[0];
        vector<int> cnt(256, 0);
        for (int i = 0; i < n; ++i) {
            ++ cnt[s1[i]];
        }
        for (int i = 0; i < n; ++i) {
            -- cnt[s2[i]];
            if (cnt[s2[i]] < 0) return false;
        }
        for (int i = 1; i < n; ++i) {
            if (isScramble(s1, s2, i) && isScramble(s1 + i, s2 + i, n - i)) {
                return true;
            }
            if (isScramble(s1, s2 + n - i, i) && isScramble(s1 + i, s2, n - i)) {
                return true;
            }
        }
        return false;
    }
};

\end{lstlisting}


\subsection{ Search a 2D Matrix }
\label{ Search a 2D Matrix }

\subsubsection*{Problem Description}
Write an efficient algorithm that searches for a value in an \emph{m} x \emph{n} matrix. This matrix has the following properties:

\begin{itemize}
\item Integers in each row are sorted from left to right.
\item The first integer of each row is greater than the last integer of the previous row.
\end{itemize}

For example,

Consider the following matrix:

Given \textbf{target} = \textbf{3}, return \textbf{true}.

\begin{verbatim}
[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
\end{verbatim}

\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Binary Search ]{ Binary Search }


\rightline{\href{https://oj.leetcode.com/problems/search-a-2d-matrix/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    bool searchMatrix(vector<vector<int> > &matrix, int target) {
        int n = matrix.size(), m = matrix[0].size();
        int left = 0, right = n * m - 1;
        while (left <= right) {
            int mid = (left + right) >> 1;
            if (matrix[mid / m][mid % m] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left < n * m && matrix[left / m][left % m] == target;
    }
}; 
\end{lstlisting}


\subsection{ Search for a Range }
\label{ Search for a Range }

\subsubsection*{Problem Description}
Given a sorted array of integers, find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of \emph{O}(log \emph{n}).

If the target is not found in the array, return \textbf{[-1, -1]}.

For example,


Given \textbf{[5, 7, 7, 8, 8, 10]} and target value 8,


return \textbf{[3, 4]}.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Binary Search ]{ Binary Search }


\rightline{\href{https://oj.leetcode.com/problems/search-for-a-range/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<int> searchRange(int A[], int n, int target) {
        vector <int> ans;
        int begin = findBegin(A, n, target);
        int end = findEnd(A, n, target);
        if (begin <= end) {
            ans.push_back(begin);
            ans.push_back(end);
        } else {
            ans.push_back(-1);
            ans.push_back(-1);
        }
        return ans;
    }
private:
    int findBegin(int A[], int n, int target) {
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = (left + right) >> 1;
            if (A[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
    
    int findEnd(int A[], int n, int target) {
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = (left + right) >> 1;
            if (A[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return right;
    }
}; 
\end{lstlisting}


\subsection{ Search in Rotated Sorted Array II }
\label{ Search in Rotated Sorted Array II }

\subsubsection*{Problem Description}
Follow up for "Search in Rotated Sorted Array":


What if \emph{duplicates} are allowed?

Would this affect the run-time complexity? How and why?

Write a function to determine if a given target is in the array.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Binary Search ]{ Binary Search }


\rightline{\href{https://oj.leetcode.com/problems/search-in-rotated-sorted-array-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    bool search(int A[], int n, int target) {
        if (n <= 0) return false;
        if (n == 1) return A[0] == target;
        int left = 0, right = n - 1, mid = (left + right) / 2;
        if (A[left] == target || A[right] == target || A[mid] == target) return true;
        if (A[left] < A[mid]) {
            if (A[left] < target && target < A[mid]) {
                return search(A + left + 1, mid - left - 1, target);
            } else {
                return search(A + mid + 1, right - mid - 1, target);
            }
        }
        if (A[mid] < A[right]) {
            if (A[mid] < target && target < A[right]) {
                return search(A + mid + 1, right - mid - 1, target);
            } else {
                return search(A + left + 1, mid - left - 1, target);
            }
        }
        return search(A + left + 1, mid - left - 1, target) || search(A + mid + 1, right - mid - 1, target);
    }
}; 
\end{lstlisting}


\subsection{ Search in Rotated Sorted Array }
\label{ Search in Rotated Sorted Array }

\subsubsection*{Problem Description}
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

(i.e., \textbf{0 1 2 4 5 6 7} might become \textbf{4 5 6 7 0 1 2}).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Binary Search ]{ Binary Search }


\rightline{\href{https://oj.leetcode.com/problems/search-in-rotated-sorted-array/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int search(int A[], int n, int target) {
        int pivot = findPivot(A, n), idx;
        if (target >= A[0]) {
            idx = find(A, pivot, target);
            if (idx == pivot || A[idx] != target) {
                idx = -1;
            }
        } else {
            idx = find(A + pivot, n - pivot, target) + pivot;
            if (idx == n || A[idx] != target) {
                idx = -1;
            }
        }
        return idx;
    }
private:
    int findPivot(int A[], int n) {
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = (left + right) >> 1;
            if (A[mid] >= A[0]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
    int find(int A[], int n, int target) {
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = (left + right) >> 1;
            if (A[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
}; 
\end{lstlisting}


\subsection{ Search Insert Position }
\label{ Search Insert Position }

\subsubsection*{Problem Description}
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Here are few examples.


\textbf{[1,3,5,6]}, 5 → 2


\textbf{[1,3,5,6]}, 2 → 1


\textbf{[1,3,5,6]}, 7 → 4


\textbf{[1,3,5,6]}, 0 → 0


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Binary Search ]{ Binary Search }


\rightline{\href{https://oj.leetcode.com/problems/search-insert-position/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int searchInsert(int A[], int n, int target) {
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = (left + right) >> 1;
            if (A[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
}; 
\end{lstlisting}


\subsection{ Set Matrix Zeroes }
\label{ Set Matrix Zeroes }

\subsubsection*{Problem Description}
Given a \emph{m} x \emph{n} matrix, if an element is 0, set its entire row and column to 0. Do it in place.

Did you use extra space?


A straight forward solution using O(\emph{m}\emph{n}) space is probably a bad idea.


A simple improvement uses O(\emph{m} + \emph{n}) space, but still not the best solution.


Could you devise a constant space solution?


\textbf{Tags: }
\hyperref[ Array ]{ Array }


\rightline{\href{https://oj.leetcode.com/problems/set-matrix-zeroes/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    void setZeroes(vector<vector<int> > &matrix) {
        if (matrix.size() == 0) return ;
        int n = matrix.size(), m = matrix[0].size();
        vector<bool> row(n, false), col(m, false);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (matrix[i][j] == 0) {
                    row[i] = col[j] = true;
                }
            }
        }
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (row[i] || col[j]) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
}; 
\end{lstlisting}


\subsection{ Simplify Path }
\label{ Simplify Path }

\subsubsection*{Problem Description}
Given an absolute path for a file (Unix-style), simplify it.

For example,


\textbf{path} = \textbf{"/home/"}, =$>$ \textbf{"/home"}


\textbf{path} = \textbf{"/a/./b/../../c/"}, =$>$ \textbf{"/c"}

Did you consider the case where \textbf{path} = \textbf{"/../"}?


In this case, you should return \textbf{"/"}.
Another corner case is the path might contain multiple slashes \textbf{'/'} together, such as \textbf{"/home//foo/"}.


In this case, you should ignore redundant slashes and return \textbf{"/home/foo"}.\begin{itemize}
\item Did you consider the case where \textbf{path} = \textbf{"/../"}?


In this case, you should return \textbf{"/"}.
\item Another corner case is the path might contain multiple slashes \textbf{'/'} together, such as \textbf{"/home//foo/"}.


In this case, you should ignore redundant slashes and return \textbf{"/home/foo"}.
\end{itemize}


\textbf{Tags: }
\hyperref[ Stack ]{ Stack },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/simplify-path/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    string simplifyPath(string path) {
        vector<string> files = split(path);
        vector<string> newfiles;
        for (int i = 0; i < files.size(); ++i) {
            if (files[i] == "..") {
                if (newfiles.size()) newfiles.pop_back();
            } else if (files[i] == "" || files[i] == ".") {
                
            } else {
                newfiles.push_back(files[i]);
            }
        }
        if (newfiles.size() == 0) return "/";
        string newpath;
        for (int i = 0; i < newfiles.size(); ++i) {
            newpath.push_back('/');
            for (int j = 0; j < newfiles[i].size(); ++j) {
                newpath.push_back(newfiles[i][j]);
            }
        }
        return newpath;
    }
private:
    vector<string> split(string path, char c = '/') {
        vector<string> ans;
        string dir;
        for (int i = 0; i < path.size(); ++i) {
            if (path[i] == c) {
                ans.push_back(dir);
                dir = "";
            } else {
                dir.push_back(path[i]);
            }
        }
        ans.push_back(dir);
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Single Number II }
\label{ Single Number II }

\subsubsection*{Problem Description}
Given an array of integers, every element appears \emph{three} times except for one. Find that single one.

\textbf{Note:}
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?


\textbf{Tags: }
\hyperref[ Bit Manipulation ]{ Bit Manipulation }


\rightline{\href{https://oj.leetcode.com/problems/single-number-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
typedef long long LL;
public:
    int singleNumber(int A[], int n) {
        LL ans = 0, x;
        for (int i = 0; i < n; ++i) {
            x = A[i];
            ans = xor3(ans, abs(x));
        }
        int cnt = 0;
        for (int i = 0; i < n; ++i) {
            if (A[i] == ans) {
                ++ cnt;
            }
        }
        return cnt == 1? ans: -ans;
    }
private:
    LL xor3(LL x, LL y) {
        if (x == 0 || y == 0) {
            return x ^ y;
        }
        return xor3(x / 3, y / 3) * 3 + (x % 3 + y % 3) % 3;
    }
}; 
\end{lstlisting}


\subsection{ Single Number II2 }
\label{ Single Number II2 }

\subsubsection*{Problem Description}

\textbf{Tags: }


\rightline{\href{https://oj.leetcode.com/problems/single-number-ii2/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
typedef long long LL;
public:
    int singleNumber(int A[], int n) {
        return single((unsigned*)(A), n);
    }

private:
    int single(unsigned A[], int n) {
        if (n == 1) return A[0];
        unsigned remind = 0;
        for (int i = 0; i < n; ++i) {
            remind = (remind + A[i] % 3) % 3;
        }
        int m = 0;
        for (int i = 0; i < n; ++i) {
            if (A[i] % 3 == remind) {
                A[m++] = A[i] / 3;
            }
        }
        return single(A, m) * 3 + remind;
    }
};

\end{lstlisting}


\subsection{ Single Number II3 }
\label{ Single Number II3 }

\subsubsection*{Problem Description}

\textbf{Tags: }


\rightline{\href{https://oj.leetcode.com/problems/single-number-ii3/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int singleNumber(int A[], int n) {
        int cnt0 = ~0, cnt1 = 0, cnt2 = 0;
        for (int i = 0; i < n; ++i) {
            int cnt2_ = cnt2;
            cnt2 = (cnt2 & ~A[i]) | (cnt1 & A[i]);
            cnt1 = (cnt1 & ~A[i]) | (cnt0 & A[i]);
            cnt0 = (cnt0 & ~A[i]) | (cnt2_ & A[i]);
        }
        return cnt1;
    }
}; 
\end{lstlisting}


\subsection{ Single Number }
\label{ Single Number }

\subsubsection*{Problem Description}
Given an array of integers, every element appears \emph{twice} except for one. Find that single one.

\textbf{Note:}
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?


\textbf{Tags: }
\hyperref[ Hash Table ]{ Hash Table },  \hyperref[ Bit Manipulation ]{ Bit Manipulation }


\rightline{\href{https://oj.leetcode.com/problems/single-number/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int singleNumber(int A[], int n) {
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans ^= A[i];
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Sort Colors }
\label{ Sort Colors }

\subsubsection*{Problem Description}
Given an array with \emph{n} objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

\textbf{Note:}


You are not suppose to use the library's sort function for this problem.

\textbf{Follow up:}


A rather straight forward solution is a two-pass algorithm using counting sort.


First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.

Could you come up with an one-pass algorithm using only constant space?


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Two Pointers ]{ Two Pointers },  \hyperref[ Sort ]{ Sort }


\rightline{\href{https://oj.leetcode.com/problems/sort-colors/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    void sortColors(int A[], int n) {
        int count[3] = {0};
        for (int i = 0; i < n; ++i) {
            ++ count[A[i]];
        }
        for (int i = 0, k = 0; i < 3; ++i) {
            for (int j = 0; j < count[i]; ++j, ++k) {
                A[k] = i;
            }
        }
    }
}; 
\end{lstlisting}


\subsection{ Sort List }
\label{ Sort List }

\subsubsection*{Problem Description}
Sort a linked list in \emph{O}(\emph{n} log \emph{n}) time using constant space complexity.


\textbf{Tags: }
\hyperref[ Linked List ]{ Linked List },  \hyperref[ Sort ]{ Sort }


\rightline{\href{https://oj.leetcode.com/problems/sort-list/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *sortList(ListNode *head) {
        if (head == NULL || head->next == NULL) return head;
        ListNode* h1, *h2;
        cut(head, h1, h2);
        h1 = sortList(h1);
        h2 = sortList(h2);
        return merger(h1, h2);
    }
    
private:
    void cut(ListNode *head, ListNode* &h1, ListNode* &h2) {
        ListNode* p;
        p = h1 = h2 = head;
        for (int i = 0; p != NULL; ++i, p = p->next) {
            if (i && i % 2 == 0) {
                h2 = h2->next;
            }
        }
        p = h2, h2 = h2->next, p->next = NULL;
    }
    
    ListNode* merger(ListNode* h1, ListNode* h2) {
        ListNode *head, *tail, *p;
        if (h1->val < h2->val) {
            tail = head = h1;
            h1 = h1->next;
        } else {
            tail = head = h2;
            h2 = h2->next;
        }
        while (h1 || h2) {
            if (h1 && h2) {
                if (h1->val < h2->val) {
                    p = h1, h1 = h1->next;
                } else {
                    p = h2, h2 = h2->next;
                }
            } else if (!h1 && h2) {
                p = h2, h2 = h2->next;
            } else if (h1 && !h2) {
                p = h1, h1 = h1->next;
            }
            tail->next = p;
            tail = p;
        }
        tail->next = NULL;
        return head;
    }
}; 
\end{lstlisting}


\subsection{ Spiral Matrix II }
\label{ Spiral Matrix II }

\subsubsection*{Problem Description}
Given an integer \emph{n}, generate a square matrix filled with elements from 1 to \emph{n}2 in spiral order.

For example,


Given \emph{n} = \textbf{3},

\begin{verbatim}
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
\end{verbatim}

\textbf{Tags: }
\hyperref[ Array ]{ Array }


\rightline{\href{https://oj.leetcode.com/problems/spiral-matrix-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
int dir[][2] = {0, 1, 1, 0, 0, -1, -1, 0};

class Solution {
public:
    vector<vector<int> > generateMatrix(int n) {
        if (n == 0) return ans;
        ans = vector<vector<int> >(n, vector<int>(n, 0));
        DFS(0, n, 0, 0, 0);
        return ans;
    }
private:
    void DFS(int k, int n, int x, int y, int d) {
        if (k == n * n) {
            return ;
        }
        ans[x][y] = k + 1;
        int nx = x + dir[d][0], ny = y + dir[d][1];
        if (!(0 <= nx && nx < n && 0 <= ny && ny < n) || ans[nx][ny]) {
            d = (d + 1) % 4;
            nx = x + dir[d][0], ny = y + dir[d][1];
        }
        DFS(k + 1, n, nx, ny, d);
    }
    vector<vector<int> > ans;
};

\end{lstlisting}


\subsection{ Spiral Matrix }
\label{ Spiral Matrix }

\subsubsection*{Problem Description}
Given a matrix of \emph{m} x \emph{n} elements (\emph{m} rows, \emph{n} columns), return all elements of the matrix in spiral order.

For example,


Given the following matrix:

You should return \textbf{[1,2,3,6,9,8,7,4,5]}.

\begin{verbatim}
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
\end{verbatim}

\textbf{Tags: }
\hyperref[ Array ]{ Array }


\rightline{\href{https://oj.leetcode.com/problems/spiral-matrix/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
int dir[][2] = {0, 1, 1, 0, 0, -1, -1, 0};

class Solution {
public:
    vector<int> spiralOrder(vector<vector<int> > &matrix) {
        ans.clear();
        if (matrix.size() == 0) return ans;
        visted = vector<vector<bool> >(matrix.size(), vector<bool>(matrix[0].size(), false));
        _gen(matrix, 0, 0, 0);
        return ans;
    }
private:
    void _gen(vector<vector<int> > &matrix, int x, int y, int d) {
        int n = matrix.size(), m = matrix[0].size();
        ans.push_back(matrix[x][y]);
        visted[x][y] = true;
        if (ans.size() == n * m) return ;
        int nx = x + dir[d][0], ny = y + dir[d][1];
        if ((0 <= nx && nx < n && 0 <= ny && ny < m) && !visted[nx][ny]) {
            _gen(matrix, nx, ny, d);
        } else {
            d = (d + 1) % 4;
            _gen(matrix, x + dir[d][0], y + dir[d][1], d);
        }
    }
    vector<vector<bool> > visted;
    vector<int> ans;
}; 
\end{lstlisting}


\subsection{ Sqrt(x) }
\label{ Sqrt(x) }

\subsubsection*{Problem Description}

\textbf{Tags: }


\rightline{\href{https://oj.leetcode.com/problems/sqrt(x)/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int sqrt(int x) {
        long long left = 0, right = x, mid;
        while(left <= right) {
            mid = (left + right) / 2;
            if (mid * mid <= x) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return right;
    }
}; 
\end{lstlisting}


\subsection{ String to Integer (atoi) }
\label{ String to Integer (atoi) }

\subsubsection*{Problem Description}

\textbf{Tags: }


\rightline{\href{https://oj.leetcode.com/problems/string-to-integer-(atoi)/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int atoi(const char *str) {
        long long ans = 0;
        int sign = 1;
        char *p = (char *)str;
        while (*p == ' ' || *p == '\t' || *p == '\n') ++p;
        if (*p == '-') {
            sign = -1;
            ++p;
        } else if (*p == '+') {
            ++p;
        }
        while (*p && '0' <= *p && *p <= '9') {
            ans = ans * 10 + (*p++ - '0');
            if (ans >= 2147483648) {
                return sign == 1? 2147483647: -2147483648;
            }
        }
        return ans * sign;
    }
}; 
\end{lstlisting}


\subsection{ Subsets II }
\label{ Subsets II }

\subsubsection*{Problem Description}
Given a collection of integers that might contain duplicates, \emph{S}, return all possible subsets.

\textbf{Note:}


\begin{itemize}
\item Elements in a subset must be in non-descending order.
\item The solution set must not contain duplicate subsets.
\end{itemize}

For example,


If \textbf{\emph{S}} = \textbf{[1,2,2]}, a solution is:

\begin{verbatim}
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
\end{verbatim}

\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Backtracking ]{ Backtracking }


\rightline{\href{https://oj.leetcode.com/problems/subsets-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<vector<int> > subsetsWithDup(vector<int> &S) {
        ans.clear();
        now.clear();
        sort(S.begin(), S.end());
        _gen(S, 0, true);
        return ans;
    }
private:
    void _gen(vector<int> &S, int k, bool last) {
        if (k == S.size()) {
            ans.push_back(now);
            return ;
        }
        
        _gen(S, k + 1, false);
        
        if (!(last == false && S[k] == S[k - 1])) {
            now.push_back(S[k]);
            _gen(S, k + 1, true);
            now.pop_back();
        }
    }
    vector<vector<int> > ans;
    vector<int> now;
}; 
\end{lstlisting}


\subsection{ Subsets }
\label{ Subsets }

\subsubsection*{Problem Description}
Given a set of distinct integers, \emph{S}, return all possible subsets.

\textbf{Note:}


\begin{itemize}
\item Elements in a subset must be in non-descending order.
\item The solution set must not contain duplicate subsets.
\end{itemize}

For example,


If \textbf{\emph{S}} = \textbf{[1,2,3]}, a solution is:

\begin{verbatim}
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
\end{verbatim}

\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Backtracking ]{ Backtracking },  \hyperref[ Bit Manipulation ]{ Bit Manipulation }


\rightline{\href{https://oj.leetcode.com/problems/subsets/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<vector<int> > subsets(vector<int> &S) {
        vector<vector<int> > ans;
        vector<int> now;
        sort(S.begin(), S.end());
        _gen(S, 0, now, ans);
        return ans;
    }
private:
    void _gen(vector<int> &S, int k, vector<int> &now, vector<vector<int> > &ans, bool c = true) {
        if (k == S.size()) {
            ans.push_back(now);
            return ;
        }
        _gen(S, k + 1, now, ans, false);
        if (c == false && S[k - 1] == S[k]) return;
        now.push_back(S[k]);
        _gen(S, k + 1, now, ans, true);
        now.pop_back();
    }
}; 
\end{lstlisting}


\subsection{ Substring with Concatenation of All Words }
\label{ Substring with Concatenation of All Words }

\subsubsection*{Problem Description}
You are given a string, \textbf{S}, and a list of words, \textbf{L}, that are all of the same length. Find all starting indices of substring(s) in S that is a concatenation of each word in L exactly once and without any intervening characters.

For example, given:


\textbf{S}: \textbf{"barfoothefoobarman"}


\textbf{L}: \textbf{["foo", "bar"]}

You should return the indices: \textbf{[0,9]}.


(order does not matter).


\textbf{Tags: }
\hyperref[ Hash Table ]{ Hash Table },  \hyperref[ Two Pointers ]{ Two Pointers },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/substring-with-concatenation-of-all-words/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
#define maxn 100000

struct _TreeNode {
    _TreeNode * c[26], *fail;
    int Lid;
    _TreeNode() {
        init();
    }
    void init() {
        for (int i = 0; i < 26; ++i) {
            c[i] = NULL;
        }
        fail = NULL;
        Lid = -1;
    }
}nodes[maxn], *que[maxn];

class Solution {
public:
    vector<int> findSubstring(string S, vector<string> &L) {
        vector<int> ans;
        if (S.size() == 0 || L.size() == 0) return ans;
        int len = L[0].size(), n = 0;
        vector<int> cnt(L.size(), 0);
        
        sort(L.begin(), L.end());
        cnt[n++] = 1;
        for (int i = 1; i < L.size(); ++i) {
            if (L[i] == L[n - 1]) {
                ++ cnt[n - 1];
            } else {
                L[n++] = L[i];
                cnt[n - 1] = 1;
            }
        }
        vector<int> f(S.size());
        
        cntnode = 0;
        nodes[cntnode].init();
        _TreeNode *root = &nodes[cntnode++];
        for (int i = 0; i < n; ++i) {
            insert(root, L[i].c_str(), i);
        }
        
        createAC(root);
        
        _TreeNode *pos = root;
        for (int i = 0; i < S.size(); ++i) {
            while (pos != root && pos->c[S[i] - 'a'] == NULL) {
                pos = pos->fail;
                assert(pos != NULL);
            }
            if (pos->c[S[i] - 'a'] != NULL) {
                pos = pos->c[S[i] - 'a'];
            }
            f[i] = pos->Lid;
        }
        
        for (int i = 0; i < len; ++i) {
            vector<int> visted(n, 0);
            int cntL = 0;
            for (int j = i; j < S.size(); j += len) {
                if (f[j] != -1) {
                    ++ visted[f[j]];
                    if (visted[f[j]] == cnt[f[j]]) {
                        ++ cntL;
                    }
                }
                int out = j - len * L.size();
                if (out >= 0 && f[out] != -1) {
                    -- visted[f[out]];
                    if (visted[f[out]] == cnt[f[out]] - 1) {
                        -- cntL;
                    }
                }
                if (cntL == n) {
                    ans.push_back(out + 1);
                }
            }
        }
        sort(ans.begin(), ans.end());
        return ans;
    }
    
private:
    void insert(_TreeNode *root, const char s[], int Lid) {
        for (int i = 0; s[i]; ++i) {
            int k = s[i] - 'a';
            if (root->c[k] == NULL) {
                nodes[cntnode].init();
                root->c[k] = &nodes[cntnode++];
            }
            root = root->c[k];
        }
        root->Lid = Lid;
    }
    
    void createAC(_TreeNode *root) {
        int left = 0, right = 0;
        que[right++] = root;
        root->fail = root;
        while (left < right) {
            _TreeNode *now = que[left++], *pos;
            for (int i = 0; i < 26; ++i) {
                if (now->c[i] == NULL) continue;
                if (now == root) {
                    now->c[i]->fail = root;
                } else {
                    pos = now->fail;
                    while (pos != root && pos->c[i] == NULL) {
                        pos = pos->fail;
                    }
                    if (pos->c[i] != NULL) {
                        pos = pos->c[i];
                    }
                    now->c[i]->fail = pos;
                }
                que[right++] = now->c[i];
            }
        }
    }
    int cntnode;
};

\end{lstlisting}


\subsection{ Sudoku Solver }
\label{ Sudoku Solver }

\subsubsection*{Problem Description}
Write a program to solve a Sudoku puzzle by filling the empty cells.

Empty cells are indicated by the character \textbf{'.'}.

You may assume that there will be only one unique solution.





A sudoku puzzle...

...and its solution numbers marked in red.


\textbf{Tags: }
\hyperref[ Backtracking ]{ Backtracking },  \hyperref[ Hash Table ]{ Hash Table }


\rightline{\href{https://oj.leetcode.com/problems/sudoku-solver/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    void solveSudoku(vector<vector<char> > &board) {
        for (int i = 0; i < 9; ++i) for (int j = 0; j < 9; ++j) row[i][j] = col[i][j] = blk[i][j] = false;
        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                if (board[i][j] != '.') {
                    int c = board[i][j] - '1';
                    row[i][c] = col[j][c] = blk[i / 3 * 3 + j / 3][c] = true;
                }
            }
        }
        solve(board, 0);
    }
    
private:
    bool solve(vector<vector<char> > &board, int k) {
        if (k == 81) return true;
        int x = k / 9, y = k % 9;
        if (board[x][y] != '.') return solve(board, k + 1);
        for (int i = 0; i < 9; ++i) {
            if (!(row[x][i] || col[y][i] || blk[x / 3 * 3 + y / 3][i])) {
                row[x][i] = col[y][i] = blk[x / 3 * 3 + y / 3][i] = true;
                board[x][y] = i + '1';
                if(solve(board, k + 1)) return true;
                board[x][y] = '.';
                row[x][i] = col[y][i] = blk[x / 3 * 3 + y / 3][i] = false;
            }
        }
        return false;
    }
    bool row[9][9], col[9][9], blk[9][9];
}; 
\end{lstlisting}


\subsection{ Sum Root to Leaf Numbers }
\label{ Sum Root to Leaf Numbers }

\subsubsection*{Problem Description}
Given a binary tree containing digits from \textbf{0-9} only, each root-to-leaf path could represent a number.

An example is the root-to-leaf path \textbf{1-$>$2-$>$3} which represents the number \textbf{123}.

Find the total sum of all root-to-leaf numbers.

For example,
\begin{verbatim}
    1
   / \
  2   3
\end{verbatim}

The root-to-leaf path \textbf{1-$>$2} represents the number \textbf{12}.


The root-to-leaf path \textbf{1-$>$3} represents the number \textbf{13}.

Return the sum = 12 + 13 = \textbf{25}.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Depth-first Search ]{ Depth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/sum-root-to-leaf-numbers/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int sumNumbers(TreeNode *root) {
        int sum = 0;
        _sumNumbers(root, 0, sum);
        return sum;
    }
private:
    void _sumNumbers(TreeNode *root, int number, int &sum) {
        if (root == NULL) return;
        number = number * 10 + root->val;
        if (root->left == NULL && root->right == NULL) {
            sum += number;
        }
        _sumNumbers(root->left , number, sum);
        _sumNumbers(root->right, number, sum);
    }
}; 
\end{lstlisting}


\subsection{ Surrounded Regions }
\label{ Surrounded Regions }

\subsubsection*{Problem Description}
Given a 2D board containing \textbf{'X'} and \textbf{'O'}, capture all regions surrounded by \textbf{'X'}.

A region is captured by flipping all \textbf{'O'}s into \textbf{'X'}s in that surrounded region.

For example,


\begin{verbatim}
X X X X
X O O X
X X O X
X O X X
\end{verbatim}

After running your function, the board should be:
\begin{verbatim}
X X X X
X X X X
X X X X
X O X X
\end{verbatim}


\textbf{Tags: }
\hyperref[ Breadth-first Search ]{ Breadth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/surrounded-regions/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    void solve(vector<vector<char> > &board) {
        if (board.size() == 0 || board[0].size() == 0) return ;
        int n = board.size(), m = board[0].size(), dir[][2] = {1, 0, -1, 0, 0, -1, 0, 1};
        
        vector<vector<bool> > visted(n, vector<bool> (m, false));
        for (int i = 0; i < n; ++i) {
            if (!visted[i][0]) {
                DFS(board, visted, i, 0, dir);
            }
            if (!visted[i][m - 1]) {
                DFS(board, visted, i, m - 1, dir);
            }
        }
        for (int i = 0; i < m; ++i) {
            if (!visted[0][i]) {
                DFS(board, visted, 0, i, dir);
            }
            if (!visted[n - 1][i]) {
                DFS(board, visted, n - 1, i, dir);
            }
        }
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (!visted[i][j]) {
                    board[i][j] = 'X';
                }
            }
        }
    }
private:
    void DFS(vector<vector<char> > &board, vector<vector<bool> > &visted, int x, int y, int dir[][2]) {
        int n = board.size(), m = board[0].size();
        if (!(0 <= x && x < n && 0 <= y && y < m)) return ;
        if (board[x][y] == 'X' || visted[x][y]) return;
        visted[x][y] = true;
        for (int i = 0; i < 4; ++i) {
            DFS(board, visted, x + dir[i][0], y + dir[i][1], dir);
        }
    }
}; 
\end{lstlisting}


\subsection{ Swap Nodes in Pairs }
\label{ Swap Nodes in Pairs }

\subsubsection*{Problem Description}
Given a linked list, swap every two adjacent nodes and return its head.

For example,


Given \textbf{1-$>$2-$>$3-$>$4}, you should return the list as \textbf{2-$>$1-$>$4-$>$3}.

Your algorithm should use only constant space. You may \textbf{not} modify the values in the list, only nodes itself can be changed.


\textbf{Tags: }
\hyperref[ Linked List ]{ Linked List }


\rightline{\href{https://oj.leetcode.com/problems/swap-nodes-in-pairs/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *swapPairs(ListNode *head) {
        ListNode newhead(0);
        newhead.next = head;
        for (ListNode *p = head, *pre = &newhead; p && p->next; pre = p, p = p->next) {
            pre->next = p->next;
            p->next = p->next->next;
            pre->next->next = p;
        }
        return newhead.next;
    }
}; 
\end{lstlisting}


\subsection{ Symmetric Tree }
\label{ Symmetric Tree }

\subsubsection*{Problem Description}
Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree is symmetric:
\begin{verbatim}
    1
   / \
  2   2
 / \ / \
3  4 4  3
\end{verbatim}

But the following is not:


\begin{verbatim}
    1
   / \
  2   2
   \   \
   3    3
\end{verbatim}

\textbf{Note:}


Bonus points if you could solve it both recursively and iteratively.

The serialization of a binary tree follows a level order traversal, where '\#' signifies a path terminator where no node exists below.

Here's an example:


\begin{verbatim}
   1
  / \
 2   3
    /
   4
    \
     5
\end{verbatim}
The above binary tree is serialized as \textbf{"\{1,2,3,\#,\#,4,\#,\#,5\}"}.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Depth-first Search ]{ Depth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/symmetric-tree/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode *root) {
        if (root == NULL) return true;
        return _isSymmetric(root->left, root->right);
    }
private:
    bool _isSymmetric(TreeNode *root1, TreeNode *root2) {
        if (root1 == NULL || root2 == NULL) {
            return root1 == root2;
        }
        if (root1->val != root2->val) return false;
        return _isSymmetric(root1->left, root2->right) && _isSymmetric(root1->right, root2->left);
    }
}; 
\end{lstlisting}


\subsection{ Text Justification }
\label{ Text Justification }

\subsubsection*{Problem Description}
Given an array of words and a length \emph{L}, format the text such that each line has exactly \emph{L} characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces \textbf{' '} when necessary so that each line has exactly \emph{L} characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left justified and no extra space is inserted between words.

For example,


\textbf{words}: \textbf{["This", "is", "an", "example", "of", "text", "justification."]}


\textbf{L}: \textbf{16}.

Return the formatted lines as:


\begin{verbatim}
[
   "This    is    an",
   "example  of text",
   "justification.  "
]
\end{verbatim}

\textbf{Note:} Each word is guaranteed not to exceed \emph{L} in length.

A line other than the last line might contain only one word. What should you do in this case?


In this case, that line should be left-justified.\begin{itemize}
\item A line other than the last line might contain only one word. What should you do in this case?


In this case, that line should be left-justified.
\end{itemize}


\textbf{Tags: }
\hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/text-justification/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<string> fullJustify(vector<string> &words, int L) {
        vector<string> ans;
        int p = 0, n = words.size();
        while (p < n) {
            int q = p + 1, tot_len = words[p].size();
            while (q < n && tot_len + words[q].size() + q - p <= L) {
                tot_len += words[q++].size();
            }
            int cntword = q - p;
            int cntspace = cntword - 1;
            string line = words[p];
            if (cntword == 1) {
                for (int i = 0; i < L - words[p].size(); ++i) {
                    line.push_back(' ');
                }
            } else if (q < n) {
                for (int i = 1; i <= cntspace; ++i) {
                    int space = (L - tot_len) / cntspace + (i <= (L - tot_len) % cntspace);
                    for (int j = 0; j < space; ++j) {
                        line.push_back(' ');
                    }
                    for (int j = 0; j < words[p + i].size(); ++j) {
                        line.push_back(words[p + i][j]);
                    }
                }
            } else {
                for (int i = p + 1; i < q; ++i) {
                    line.push_back(' ');
                    for (int j = 0; j < words[i].size(); ++j) {
                        line.push_back(words[i][j]);
                    }
                }
                int left = L - line.size();
                for (int i = 0; i < left; ++i) {
                    line.push_back(' ');
                }
            }
            ans.push_back(line);
            p = q;
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Trapping Rain Water }
\label{ Trapping Rain Water }

\subsubsection*{Problem Description}
Given \emph{n} non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

For example, 


Given \textbf{[0,1,0,2,1,0,1,3,2,1,2,1]}, return \textbf{6}.

The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. \textbf{Thanks Marcos} for contributing this image!


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Stack ]{ Stack },  \hyperref[ Two Pointers ]{ Two Pointers }


\rightline{\href{https://oj.leetcode.com/problems/trapping-rain-water/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int trap(int A[], int n) {
        if (n <= 2) return 0;
        int stk[n], top = 0, ans = 0;
        for (int i = 0; i < n; ++i) {
            while (top && A[stk[top - 1]] <= A[i]) {
                if (top >= 2) {
                    ans += (min(A[stk[top - 2]], A[i])  - A[stk[top - 1]]) * (i - stk[top - 2] - 1);
                }
                -- top;
            }
            stk[top++] = i;
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Triangle }
\label{ Triangle }

\subsubsection*{Problem Description}
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

For example, given the following triangle


\begin{verbatim}
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
\end{verbatim}

The minimum path sum from top to bottom is \textbf{11} (i.e., 2 + 3 + 5 + 1 = 11).

\textbf{Note:}


Bonus point if you are able to do this using only \emph{O}(\emph{n}) extra space, where \emph{n} is the total number of rows in the triangle.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Dynamic Programming ]{ Dynamic Programming }


\rightline{\href{https://oj.leetcode.com/problems/triangle/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int minimumTotal(vector<vector<int> > &triangle) {
        for (int i = triangle.size() - 2; i >= 0; --i) {
            for (int j = 0; j <= i; ++j) {
                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);
            }
        }
        return triangle[0][0];
    }
}; 
\end{lstlisting}


\subsection{ Two Sum }
\label{ Two Sum }

\subsubsection*{Problem Description}
Given an array of integers, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.

You may assume that each input would have exactly one solution.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Hash Table ]{ Hash Table }


\rightline{\href{https://oj.leetcode.com/problems/two-sum/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<int> twoSum(vector<int> &numbers, int target) {
        vector<int> ans;
        for (int i = 0; i < numbers.size(); ++i) {
            for (int j = i + 1; j < numbers.size(); ++j) {
                if (numbers[i] + numbers[j] == target) {
                    ans.push_back(i + 1), ans.push_back(j + 1);
                    return ans;
                }
            }
        }
    }
}; 
\end{lstlisting}


\subsection{ Unique Binary Search Trees II }
\label{ Unique Binary Search Trees II }

\subsubsection*{Problem Description}
Given \emph{n}, generate all structurally unique \textbf{BST's} (binary search trees) that store values 1...\emph{n}.

For example,


Given \emph{n} = 3, your program should return all 5 unique BST's shown below.

\begin{verbatim}
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
\end{verbatim}

The serialization of a binary tree follows a level order traversal, where '\#' signifies a path terminator where no node exists below.

Here's an example:


\begin{verbatim}
   1
  / \
 2   3
    /
   4
    \
     5
\end{verbatim}
The above binary tree is serialized as \textbf{"\{1,2,3,\#,\#,4,\#,\#,5\}"}.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Dynamic Programming ]{ Dynamic Programming }


\rightline{\href{https://oj.leetcode.com/problems/unique-binary-search-trees-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<TreeNode *> generateTrees(int n) {
        return _gen(1, n);
    }
private:
    vector<TreeNode *> _gen(int left, int right) {
        vector<TreeNode *> roots;
        if (left > right)  {
            roots.push_back(NULL);
            return roots;
        }
        for (int k = left; k <= right; ++k) {
            vector<TreeNode *> lefttree = _gen(left, k - 1);
            vector<TreeNode *> righttree = _gen(k + 1, right);
            for (int i = 0; i < lefttree.size(); ++i) {
                for (int j = 0; j < righttree.size(); ++j) {
                    TreeNode *root = new TreeNode(k);
                    root->left = lefttree[i];
                    root->right = righttree[j];
                    roots.push_back(root);
                }
            }
        }
        return roots;
    }
}; 
\end{lstlisting}


\subsection{ Unique Binary Search Trees }
\label{ Unique Binary Search Trees }

\subsubsection*{Problem Description}
Given \emph{n}, how many structurally unique \textbf{BST's} (binary search trees) that store values 1...\emph{n}?

For example,


Given \emph{n} = 3, there are a total of 5 unique BST's.

\begin{verbatim}
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
\end{verbatim}


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Dynamic Programming ]{ Dynamic Programming }


\rightline{\href{https://oj.leetcode.com/problems/unique-binary-search-trees/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int numTrees(int n) {
        return C(2 * n, n) / (n + 1);
    }
private:
    long long C(int n, int m) {
        long long ans = 1;
        for (int i = 1; i <= m; ++i) {
            ans = ans * (n - i + 1) / i;
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Unique Paths II }
\label{ Unique Paths II }

\subsubsection*{Problem Description}
Follow up for "Unique Paths":

Now consider if some obstacles are added to the grids. How many unique paths would there be?

An obstacle and empty space is marked as \textbf{1} and \textbf{0} respectively in the grid.

For example,


There is one obstacle in the middle of a 3x3 grid as illustrated below.

The total number of unique paths is \textbf{2}.

\textbf{Note:} \emph{m} and \emph{n} will be at most 100.

\begin{verbatim}
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
\end{verbatim}

\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Dynamic Programming ]{ Dynamic Programming }


\rightline{\href{https://oj.leetcode.com/problems/unique-paths-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {
        if (obstacleGrid.size() == 0) return 0;
        int n = obstacleGrid.size(), m = obstacleGrid[0].size();
        vector<vector<int> > f(n, vector<int>(m, 0));
        
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) if (obstacleGrid[i][j] == 0) {
                if (i && j) {
                    f[i][j] = f[i - 1][j] + f[i][j - 1];
                } else if (i && !j) {
                    f[i][j] = f[i - 1][j];
                } else if (!i && j) {
                    f[i][j] = f[i][j - 1];
                } else {
                    f[i][j] = 1;
                }
            }
        }
        return f[n - 1][m - 1];
    }
}; 
\end{lstlisting}


\subsection{ Unique Paths }
\label{ Unique Paths }

\subsubsection*{Problem Description}
A robot is located at the top-left corner of a \emph{m} x \emph{n} grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?

Above is a 3 x 7 grid. How many possible unique paths are there?

\textbf{Note:} \emph{m} and \emph{n} will be at most 100.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Dynamic Programming ]{ Dynamic Programming }


\rightline{\href{https://oj.leetcode.com/problems/unique-paths/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    int uniquePaths(int m, int n) {
        return C(n + m -2, n - 1);
    }
private:
    int C(int n, int m) {
        m = min(m, n - m);
        long long ans = 1;
        for (int i = 1; i <= m; ++i) {
            ans = ans * (n - i + 1) / i;
        }
        return ans;
    }
}; 
\end{lstlisting}


\subsection{ Valid Number }
\label{ Valid Number }

\subsubsection*{Problem Description}
Validate if a given string is numeric.

Some examples:


\textbf{"0"} =$>$ \textbf{true}


\textbf{"   0.1  "} =$>$ \textbf{true}


\textbf{"abc"} =$>$ \textbf{false}


\textbf{"1 a"} =$>$ \textbf{false}


\textbf{"2e10"} =$>$ \textbf{true}

\textbf{Note:} It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.

\textbf{Update (2014-12-06):}
New test cases had been added. Thanks \textbf{unfounder}'s contribution.


\textbf{Tags: }
\hyperref[ Math ]{ Math },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/valid-number/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    bool isNumber(const char *s) {
        int left = 0, right = strlen(s) - 1;
        while(left <= right && (s[left] == ' ' || s[left] == '\t' || s[left] == '\n')) {
            ++ left;
        }
        while(left <= right && (s[right] == ' ' || s[right] == '\t' || s[right] == '\n')) {
            -- right;
        }
        if (left > right) return false;
        int cnt_dot = 0, cnt_e = 0, pos_e = 0;
        for (int i = left; i <= right; ++i) {
            if (!('0' <= s[i] && s[i] <= '9')) {
                if (s[i] == '.') {
                    ++ cnt_dot;
                } else if (s[i] == 'e' || s[i] == 'E'){
                    ++ cnt_e;
                    pos_e = i;
                } else if (s[i] != '-' && s[i] != '+'){
                    return false;
                }
            }
        }
        if (cnt_e > 1 || cnt_dot > 1) {
            return false;
        }
        if ((cnt_e && isFloat(s, left, pos_e - 1) && isInt(s, pos_e + 1, right)) || (!cnt_e && isFloat(s, left, right))) {
            return true;
        }
        return false;
    }
private:
    bool isFloat(const char *s, int left, int right) {
        if (left <= right && (s[left] == '-' || s[left] == '+')) {
            ++left;
        }
        if (left > right) return false;
        if (s[left] == '.' && left == right) {
            return false;
        }
        for (int i = left; i <= right; ++i) {
            if (!('0' <= s[i] && s[i] <= '9' || s[i] == '.')) {
                return false;
            }
        }
        return true;
    }
    
    bool isInt(const char *s, int left, int right) {
        if (left <= right && (s[left] == '-' || s[left] == '+')) {
            ++ left;
        }
        if (left > right) return false;
        for (int i = left; i <= right; ++i) {
            if (!('0' <= s[i] && s[i] <= '9')) {
                return false;
            }
        }
        return true;
    }
};

\end{lstlisting}


\subsection{ Valid Palindrome }
\label{ Valid Palindrome }

\subsubsection*{Problem Description}
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

For example,


\textbf{"A man, a plan, a canal: Panama"} is a palindrome.


\textbf{"race a car"} is \emph{not} a palindrome.

\textbf{Note:}


Have you consider that the string might be empty? This is a good question to ask during an interview.

For the purpose of this problem, we define empty string as valid palindrome.


\textbf{Tags: }
\hyperref[ Two Pointers ]{ Two Pointers },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/valid-palindrome/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    bool isPalindrome(string s) {
        string charset;
        for (int i = 0; i < s.size(); ++i) {
            if ('A' <= s[i] && s[i] <= 'Z') {
                charset.push_back(s[i] - 'A' + 'a');
            } else if ('a' <= s[i] && s[i] <= 'z' || '0' <= s[i] && s[i] <= '9') {
                charset.push_back(s[i]);
            }
        }
        for (int i = 0; i < charset.size() / 2; ++i) {
            if (charset[i] != charset[charset.size() - i - 1]) {
                return false;
            }
        }
        return true;
    }
}; 
\end{lstlisting}


\subsection{ Valid Parentheses }
\label{ Valid Parentheses }

\subsubsection*{Problem Description}
Given a string containing just the characters \textbf{'('}, \textbf{')'}, \textbf{'\{'}, \textbf{'\}'}, \textbf{'['} and \textbf{']'}, determine if the input string is valid.

The brackets must close in the correct order, \textbf{"()"} and \textbf{"()[]\{\}"} are all valid but \textbf{"(]"} and \textbf{"([)]"} are not.


\textbf{Tags: }
\hyperref[ Stack ]{ Stack },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/valid-parentheses/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    bool isValid(string s) {
        stack<char> stk;
        for (int i = 0; i < s.size(); ++i) {
            switch(s[i]) {
                case '(':
                case '[':
                case '{':
                    stk.push(s[i]);
                    break;
                case ')':
                    if (stk.empty() || stk.top() != '(') return false;
                    stk.pop();
                    break;
                case ']':
                    if (stk.empty() || stk.top() != '[') return false;
                    stk.pop();
                    break;
                case '}':
                    if (stk.empty() || stk.top() != '{') return false;
                    stk.pop();
                    break;
            }
        }
        return stk.empty();
    }
}; 
\end{lstlisting}


\subsection{ Valid Sudoku }
\label{ Valid Sudoku }

\subsubsection*{Problem Description}
Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.

The Sudoku board could be partially filled, where empty cells are filled with the character \textbf{'.'}.

A partially filled sudoku which is valid.

\textbf{Note:}


A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.


\textbf{Tags: }
\hyperref[ Hash Table ]{ Hash Table }


\rightline{\href{https://oj.leetcode.com/problems/valid-sudoku/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    bool isValidSudoku(vector<vector<char> > &board) {
        vector<vector<bool> > row(9, vector<bool> (9, false)), col(9, vector<bool> (9, false)), blk(9, vector<bool> (9, false));
        //bool row[9][9] = {false};
        //bool col[9][9] = {false};
        //bool blk[9][9] = {false};
        
        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                if (board[i][j] != '.') {
                    int c = board[i][j] - '1';
                    if (row[i][c] || col[j][c] || blk[i / 3 * 3 + j / 3][c]) {
                        return false;
                    }
                    row[i][c] = col[j][c] = blk[i / 3 * 3 + j / 3][c] = true;
                }
            }
        }
        return true;
    }
}; 
\end{lstlisting}


\subsection{ Validate Binary Search Tree }
\label{ Validate Binary Search Tree }

\subsubsection*{Problem Description}
Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:
\begin{itemize}
\item The left subtree of a node contains only nodes with keys \textbf{less than} the node's key.
\item The right subtree of a node contains only nodes with keys \textbf{greater than} the node's key.
\item Both the left and right subtrees must also be binary search trees.
\end{itemize}

The serialization of a binary tree follows a level order traversal, where '\#' signifies a path terminator where no node exists below.

Here's an example:


\begin{verbatim}
   1
  / \
 2   3
    /
   4
    \
     5
\end{verbatim}
The above binary tree is serialized as \textbf{"\{1,2,3,\#,\#,4,\#,\#,5\}"}.


\textbf{Tags: }
\hyperref[ Tree ]{ Tree },  \hyperref[ Depth-first Search ]{ Depth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/validate-binary-search-tree/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode *root) {
        int rmax, rmin;
        return isValidBST(root, rmax, rmin);
    }
private:
    bool isValidBST(TreeNode *root, int &rmax, int &rmin) {
        if (root == NULL) return true;
        rmax = rmin = root->val;
        if (root->left) {
            int cmax, cmin;
            if (isValidBST(root->left, cmax, cmin) == false || cmax >= root->val) {
                return false;
            }
            rmax = max(rmax, cmax), rmin = min(rmin, cmin);
        }
        if (root->right) {
            int cmax, cmin;
            if (isValidBST(root->right, cmax, cmin) == false || cmin <= root->val) {
                return false;
            }
            rmax = max(rmax, cmax), rmin = min(rmin, cmin);
        }
        return true;
    }
}; 
\end{lstlisting}


\subsection{ Wildcard Matching }
\label{ Wildcard Matching }

\subsubsection*{Problem Description}
Implement wildcard pattern matching with support for \textbf{'?'} and \textbf{'*'}.

\begin{verbatim}
'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).

The matching should cover the <b>entire</b> input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "*") → true
isMatch("aa", "a*") → true
isMatch("ab", "?*") → true
isMatch("aab", "c*a*b") → false
\end{verbatim}

\textbf{Tags: }
\hyperref[ Dynamic Programming ]{ Dynamic Programming },  \hyperref[ Backtracking ]{ Backtracking },  \hyperref[ Greedy ]{ Greedy },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/wildcard-matching/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    bool isMatch(const char *s, const char *p) {
        vector<char *> blk;
        int lenp = strlen(p), lens = strlen(s);
        char cp[lenp + 1], *head = (char *)s, *tail;
        strcpy(cp, p);
        for (int i = 0; i <= lenp; ++i) {
            if (cp[i] == '*') {
                cp[i] = 0;
                if (i == 0) {
                    blk.push_back(cp + i);
                }
            } else {
                if (i == 0 || cp[i - 1] == 0) {
                    blk.push_back(cp + i);
                }
            }
        }
        
        if (blk.size() == 1 && lenp != lens) return false;
        
        tail = head + lens - strlen(blk[blk.size() - 1]);
        if (strStr(head, blk[0]) != head || strStr(tail, blk[blk.size() - 1]) != tail) {
            return false;
        }
        
        for (int i = 0; i < blk.size(); ++i) {
            head = strStr(head, blk[i]);
            if (head == NULL) return false;
            head += strlen(blk[i]);
        }
        return true;
    }
private:
    char *strStr(char *s, char *t) {
        int n = strlen(t);
        if (n == 0) return s;
        int next[n + 1], pos = 0;
        next[0] = pos;
        for (int i = 1; i < n; ++i) {
            while(pos && t[pos] != t[i] && t[i] != '?' && t[pos] != '?') {
                pos = next[pos - 1];
            }
            next[i] = pos = pos + (t[pos] == t[i] || t[pos] == '?' || t[i] == '?');
        }

        pos = 0;
        for (int i = 0; s[i]; ++i) {
            while (pos && t[pos] != '?' && t[pos] != s[i]) {
                pos = next[pos - 1];
            }
            pos += (t[pos] == s[i] || t[pos] == '?');
            if (pos == n) return s + i - n + 1;
        }
        return NULL;
    }
    
}; 
\end{lstlisting}


\subsection{ Word Break II }
\label{ Word Break II }

\subsubsection*{Problem Description}
Given a string \emph{s} and a dictionary of words \emph{dict}, add spaces in \emph{s} to construct a sentence where each word is a valid dictionary word.

Return all such possible sentences.

For example, given
\emph{s} = \textbf{"catsanddog"},
\emph{dict} = \textbf{["cat", "cats", "and", "sand", "dog"]}.

A solution is \textbf{["cats and dog", "cat sand dog"]}.


\textbf{Tags: }
\hyperref[ Dynamic Programming ]{ Dynamic Programming },  \hyperref[ Backtracking ]{ Backtracking }


\rightline{\href{https://oj.leetcode.com/problems/word-break-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    vector<string> wordBreak(string s, unordered_set<string> &dict) {
        vector<bool> f(s.size() + 1, false);
        vector<string> dicts;
        for (unordered_set<string>::iterator it = dict.begin(); it != dict.end(); ++it) {
            dicts.push_back(*it);
        }
        f[0] = true;
        for (int i = 1; i <= s.size(); ++i) {
            for (int j = 0; j < dicts.size(); ++j) {
                int cutlen = dicts[j].length();
                if (i >= cutlen && s.substr(i - cutlen, cutlen) == dicts[j]) {
                    f[i] = f[i] | f[i - cutlen];
                }
            }
        }
        vector<string> ans;
        _gen(s, dicts, f, s.size(), "", ans);
        return ans;
    }
private:
    void _gen(const string &s, vector<string> &dicts, vector<bool> &f, int k, string now, vector<string> &ans) {
        if (k == 0) {
            ans.push_back(now);
            return ;
        }
        if (f[k] == false) return ;
        for (int i = 0; i < dicts.size(); ++i) {
            int cutlen = dicts[i].length();
            if (k >= cutlen && s.substr(k - cutlen, cutlen) == dicts[i]) {
                _gen(s, dicts, f, k - cutlen, (now == "" ? dicts[i] + now: dicts[i] + " " + now), ans);
            }
        }
    }
}; 
\end{lstlisting}


\subsection{ Word Break }
\label{ Word Break }

\subsubsection*{Problem Description}
Given a string \emph{s} and a dictionary of words \emph{dict}, determine if \emph{s} can be segmented into a space-separated sequence of one or more dictionary words.

For example, given
\emph{s} = \textbf{"leetcode"},
\emph{dict} = \textbf{["leet", "code"]}.

Return true because \textbf{"leetcode"} can be segmented as \textbf{"leet code"}.


\textbf{Tags: }
\hyperref[ Dynamic Programming ]{ Dynamic Programming }


\rightline{\href{https://oj.leetcode.com/problems/word-break/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    bool wordBreak(string s, unordered_set<string> &dict) {
        vector<bool> f(s.size() + 1, false);
        vector<string> dicts;
        for (unordered_set<string>::iterator it = dict.begin(); it != dict.end(); ++it) {
            dicts.push_back(*it);
        }
        f[0] = true;
        for (int i = 1; i <= s.size(); ++i) {
            for (int j = 0; j < dicts.size(); ++j) {
                int cutlen = dicts[j].length();
                if (i >= cutlen && s.substr(i - cutlen, cutlen) == dicts[j]) {
                    f[i] = f[i] | f[i - cutlen];
                }
            }
        }
        return f[s.size()];
    }
}; 
\end{lstlisting}


\subsection{ Word Ladder II }
\label{ Word Ladder II }

\subsubsection*{Problem Description}
Given two words (\emph{start} and \emph{end}), and a dictionary, find all shortest transformation sequence(s) from \emph{start} to \emph{end}, such that:

For example,

Given:


\emph{start} = \textbf{"hit"}


\emph{end} = \textbf{"cog"}


\emph{dict} = \textbf{["hot","dot","dog","lot","log"]}

Return


\begin{verbatim}
  [
    ["hit","hot","dot","dog","cog"],
    ["hit","hot","lot","log","cog"]
  ]
\end{verbatim}

\textbf{Note:}


\begin{itemize}
\item All words have the same length.
\item All words contain only lowercase alphabetic characters.
\end{itemize}


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Backtracking ]{ Backtracking },  \hyperref[ Breadth-first Search ]{ Breadth-first Search },  \hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/word-ladder-ii/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class RotationStr {
public:
    char str[10];
    int id, len;
    RotationStr() {}
    RotationStr(string s, int id) {
        len = s.size();
        this->id = id;
        for (int i = 0; i < len; ++i) {
            str[i] = s[i];
        }
    }
    void rotate() {
        char temp = str[0];
        for (int i = 1; i < len; ++i) {
            str[i - 1] = str[i];
        }
        str[len - 1] = temp;
    }
    
    bool operator < (const RotationStr &other) const {
        return strncmp(str, other.str, len - 1) < 0;
    }
    
    bool operator == (const RotationStr &other) const {
        return strncmp(str, other.str, len - 1) == 0;
    }
};

class Solution {
public:
    vector<vector<string> > findLadders(string start, string end, unordered_set<string> &dict) {
        allstr.clear();
        res.clear();
        
        if (dict.size() == 0) return res;
        if (start == end) {
            vector<string> justone(1, start);
            res.push_back(justone);
            return  res;
        }
        
        allstr.push_back(make_pair(start, 1));
        allstr.push_back(make_pair(end, 0));
        
        for (unordered_set<string>::iterator pos = dict.begin(); pos != dict.end(); ++ pos) {
            if (*pos != start && *pos != end) {
                allstr.push_back(make_pair(*pos, 0));
            }
        }
        
        _makeLinks();
        
        int step = _ladderLen();
        
        stk.clear();
        stk.push_back(1);
        _DFS(step);
        return res;
    }
    
private:
    int _ladderLen() {
        queue<int> que;
        que.push(0);
        while (!que.empty()) {
            int now_id = que.front();
            que.pop();
            int now_step = allstr[now_id].second;
            if (now_id == 1) return now_step;
            for (int i = 0; i < links[now_id].size(); ++i) {
                if (allstr[links[now_id][i]].second == 0) {
                    allstr[links[now_id][i]].second = now_step + 1;
                    que.push(links[now_id][i]);
                }
            }
        }
        return 0;
    }
    
    void _makeLinks() {
        vector<RotationStr> dicts;
        links.clear();
        links.resize(allstr.size());
        int len = allstr[0].first.size();
        for (int i = 0; i < allstr.size(); ++i) {
            dicts.push_back(RotationStr(allstr[i].first, i));
        }
        for (int k = 0; k < len; ++k) {
            for (int i = 0; i < dicts.size(); ++i) {
                dicts[i].rotate();
            }
            sort(dicts.begin(), dicts.end());
            for (int i = 0; i < dicts.size(); ++i) {
                for (int j = i + 1; j < dicts.size() && dicts[i] == dicts[j]; ++j) {
                    links[dicts[i].id].push_back(dicts[j].id);
                    links[dicts[j].id].push_back(dicts[i].id);
                }
            }
        }
    }
    
    void _DFS(int step) {
        int now = stk[stk.size() - 1];
        if (allstr[now].second != step + 1 - stk.size()) return ;
        if (stk.size() == step) {
            if (now == 0) {
                vector<string> oneres;
                for (int i = stk.size() - 1; i >= 0; --i) {
                    oneres.push_back(allstr[stk[i]].first);
                }
                res.push_back(oneres);
            }
            return ;
        }
        for (int i = 0; i < links[now].size(); ++i) {
            stk.push_back(links[now][i]);
            _DFS(step);
            stk.pop_back();
        }
    }
    
    vector<int> stk;
    vector<vector<string> > res;
    vector<pair<string, int> > allstr;
    vector<vector<int> > links;
}; 
\end{lstlisting}


\subsection{ Word Ladder }
\label{ Word Ladder }

\subsubsection*{Problem Description}
Given two words (\emph{start} and \emph{end}), and a dictionary, find the length of shortest transformation sequence from \emph{start} to \emph{end}, such that:

For example,

Given:


\emph{start} = \textbf{"hit"}


\emph{end} = \textbf{"cog"}


\emph{dict} = \textbf{["hot","dot","dog","lot","log"]}

As one shortest transformation is \textbf{"hit" -$>$ "hot" -$>$ "dot" -$>$ "dog" -$>$ "cog"},


return its length \textbf{5}.

\textbf{Note:}


\begin{itemize}
\item Return 0 if there is no such transformation sequence.
\item All words have the same length.
\item All words contain only lowercase alphabetic characters.
\end{itemize}


\textbf{Tags: }
\hyperref[ Breadth-first Search ]{ Breadth-first Search }


\rightline{\href{https://oj.leetcode.com/problems/word-ladder/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
struct TrieTreeNode {
    int c[26];
    bool visted;
    void reset() {
        for (int i = 0; i < 26; ++i) c[i] = 0;
        visted = false;
    }
}nodes[1000000];

class Solution {
public:
    int ladderLength(string start, string end, unordered_set<string> &dict) {
        queue<pair<string, int> > que;
        
        TrieInit();
        
        for (unordered_set<string>::iterator pos = dict.begin(); pos != dict.end(); ++ pos) {
            TrieInsert(pos->c_str());
        }
        
        inTrie(start);
        que.push(make_pair(start, 1));
        
        while (!que.empty()) {
            pair<string, int> nowpair = que.front();
            que.pop();
            string &now_str = nowpair.first;
            int now_step = nowpair.second;
            
            if (now_str == end) return now_step;
            
            for (int i = 0; i < now_str.size(); ++i) {
                char oc = now_str[i];
                for (char c = 'a'; c <= 'z'; ++c) {
                    now_str[i] = c;
                    if (inTrie(now_str)) {
                        que.push(make_pair(now_str, now_step + 1));
                    }
                }
                now_str[i] = oc;
            }
        }
        return 0;
    }
    
private:
    
    void TrieInit() {
        nodes[0].reset();
        cntnodes = 1;
    }
    void TrieInsert(const char *s, int root = 0) {
        if (*s == 0) {
            return ;
        }
        int id = *s - 'a';
        if (nodes[root].c[id] == 0) {
            nodes[cntnodes].reset();
            nodes[root].c[id] = cntnodes++;
            
        }
        TrieInsert(s + 1, nodes[root].c[id]);
    }
    
    bool inTrie(string s) {
        int root = 0;
        for(int i = 0; i < s.size(); ++i) {
            if (nodes[root].c[s[i] - 'a'] == 0) {
                return false;
            }
            root = nodes[root].c[s[i] - 'a'];
        }
        return nodes[root].visted? false: (nodes[root].visted = true);
    }
    
    int cntnodes;
};

\end{lstlisting}


\subsection{ Word Search }
\label{ Word Search }

\subsubsection*{Problem Description}
Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

For example,


Given \textbf{board} = 
\begin{verbatim}
[
  ["ABCE"],
  ["SFCS"],
  ["ADEE"]
]
\end{verbatim}

\textbf{word} = \textbf{"ABCCED"}, -$>$ returns \textbf{true},


\textbf{word} = \textbf{"SEE"}, -$>$ returns \textbf{true},


\textbf{word} = \textbf{"ABCB"}, -$>$ returns \textbf{false}.


\textbf{Tags: }
\hyperref[ Array ]{ Array },  \hyperref[ Backtracking ]{ Backtracking }


\rightline{\href{https://oj.leetcode.com/problems/word-search/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
int dir[][2] = {0, 1, 0, -1, 1, 0, -1, 0};

class Solution {
public:
    bool exist(vector<vector<char> > &board, string word) {
        if (board.size() == 0) return false;
        int n = board.size(), m = board[0].size();
        visted = vector<vector<bool> >(n, vector<bool>(m, false));
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (DFS(i, j, board, word, 0)) {
                    return true;
                }
            }
        }
        return  false;
    }
    
private:
    bool DFS(int x, int y, vector<vector<char> > &board, string &word, int k) {
        if (k == word.size()) return true;
        int n = board.size(), m = board[0].size();
        if (!(0 <= x && x < n && 0 <= y && y < m && word[k] == board[x][y] && !visted[x][y])) {
            return false;
        }
        visted[x][y] = true;
        bool found = false;
        for (int i = 0; i < 4; ++i) {
            if (found = DFS(x + dir[i][0], y + dir[i][1], board, word, k + 1)) {
                break;
            }
        }
        visted[x][y] = false;
        return found;
    }
    vector<vector<bool> > visted;
}; 
\end{lstlisting}


\subsection{ ZigZag Conversion }
\label{ ZigZag Conversion }

\subsubsection*{Problem Description}
The string \textbf{"PAYPALISHIRING"} is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
\begin{verbatim}
P   A   H   N
A P L S I I G
Y   I   R
\end{verbatim}

And then read line by line: \textbf{"PAHNAPLSIIGYIR"}

Write the code that will take a string and make this conversion given a number of rows:

\begin{verbatim}string convert(string text, int nRows);\end{verbatim}

\textbf{convert("PAYPALISHIRING", 3)} should return \textbf{"PAHNAPLSIIGYIR"}.


\textbf{Tags: }
\hyperref[ String ]{ String }


\rightline{\href{https://oj.leetcode.com/problems/zigzag-conversion/}{Submit}}

\subsubsection*{Solution}
水题

\subsubsection*{Code}
\begin{lstlisting}
class Solution {
public:
    string convert(string s, int nRows) {
        if (nRows == 1) return s;
        vector<string> row(nRows);
        for (int i = 0; i < s.size(); ++i) {
            int remind = i % (2 * nRows - 2);
            if (remind < nRows) {
                row[remind].push_back(s[i]);
            } else {
                row[2 * nRows - 2 - remind].push_back(s[i]);
            }
        }
        string ans;
        for (int i = 0; i < nRows; ++i) {
            ans += row[i];
        }
        return ans;
    }
};

\end{lstlisting}


\end{CJK*}
\end{document} 
